\section{Nested Interpreters}

Right now, we have written several interpreters in C to parse and evaluate a subset of the Scheme programming language. Now, because our language is powerful enough, we will move away from writing in C to writing in the language of our latest interpreter to write an interpreter! This may seem like madness, but worry not, we will start out small.

First off, how can we even evaluate expressions in our interpreter? Do we not need a complex lexer and parser? As a matter of fact, we have all the necessary ingredients to parse complicated programs already available. Imagine we have a function called \texttt{value-of}, which computes the value of (hence the name!) some arbitrary expression. What would that function look like? Or, more importantly, what would the input data look like? We have a representation of storing an indeterminate number of items: lists. If we wanted to compute the value of, e.g., \texttt{\textquotesingle{}(3 + 4)}, what would we do? Well, we might start by extracting each piece of the list into variables.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define input (*;\textquotesingle;*)(3 + 4))
(let ([lhs-rand (first input)]
      [rator (second input)]
      [rhs-rand (third input)])
 (*;\textcolor{lightgray}{$\ldots$};*))
\end{lstlisting}\end{cl}

Extracting an element via \texttt{first} is familiar, but what are \texttt{second} and \texttt{third}? Each is a mere composition of \texttt{first} and \texttt{rest}. Thus, \texttt{(second ls)} is equivalent to \texttt{(first (rest ls))}, and \texttt{(third ls)} is equivalent to \texttt{(first (rest (rest ls)))}. This allows us to extract specific elements from a list of determined values. At this point, we may be tempted to apply the \texttt{rator} to the arguments \texttt{lhs-rand} and \texttt{rhs-rand}. Though, we need to stop and think about what we are evaluating. Right now, \texttt{rator} is \textit{not} a procedure; it is a symbol inside a list. We need a method of mapping between symbols and corresponding procedures. For example, we want to be able to map the symbol \texttt{\textquotesingle{}+} to the procedure \texttt{+}. Fortunately, we can achieve this via association lists. In Chapter~\ref{chapter-interpretation1}, we discussed association lists as a representation for environments, and we will use them here as our environment representation (for the time being, our environments will not be representation independent). Thus, we can create an environment $e_0$ to contain a list of \textit{cons} pairs, where the \textit{first} is the symbol, and the \textit{rest} is the associated primitive procedure. For the moment, we will define the global environment as containing the primitive operations for addition and subtraction. To maintain representation independence, we should design \ttt{extend-env} and \ttt{empty-env} alongside the global environment:
\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define extend-env
 ((*;$\lambda$;*) (x arg env)
  (cons (cons x arg) env)))

(define empty-env
 ((*;$\lambda$;*) ()
  `()))

(define global-env
 (extend-env '+ +
  (extend-env '- -
   (empty-env))))
\end{lstlisting}\end{cl}
The \textit{cons} pairs denote that the \textit{first} represents the symbol to search for in the environment, and the \textit{rest} is the its bound value. In the case of \ttt{\q{}+} and \ttt{\q{}-}, the bound values are the addition and subtraction procedures respectively. Now, we need a function to lookup the value of symbol in the environment. Suppose we call this function \texttt{apply-env}, which receives two arguments: a symbol to lookup, \texttt{v}, and an environment, \texttt{env}. \texttt{apply-env} recursively searches the environment for a \textit{cons} pair $p$ where the \textit{first} of $p$ matches \texttt{v}. If one exists, we return the rest of the first of the pair, i.e., the corresponding mapped value. Note that, because we are using \textit{cons} pairs, we do not need to wrap the \ttt{rest} invocation in a call to \ttt{first}.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define apply-env
 ((*;$\lambda$;*) (v env)
  (cond
   [(null? env) 'error]
   [(eqv? (first (first env)) v) (rest (first env))]
   [else (apply-env v (rest env))])))
\end{lstlisting}\end{cl}

We are on our way there! Let us continue by writing some of the \texttt{value-of} procedure. Some expressions are simple and do not require further evaluation, e.g., numbers. Symbols need to be resolved/looked up in the environment.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of
 ((*;$\lambda$;*) (expr env)
  (cond
   [(number? expr) expr]
   [(symbol? expr) (apply-env expr env)]
   [else 'error])))
\end{lstlisting}\end{cl}
Interestingly enough, this interpreter, as it stands, is all that is necessary to write a \textit{very} simple program; one that outputs the same number that it is provided. This is rather boring; why not spice it up by adding arithmatic expressions?
\begin{cloast}[]{}\begin{lstlisting}[language=MyScheme]
(*;\textbf{>};*) (value-of '5 global-env)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
5
\end{lstlisting}
\end{cloast}

\subsection*{Recognizer and Reducer Functions}
We classify a \textit{nested interpreter}\index{nested interpreter} as an interpreter for a language specification that we write in the language \textit{of} our interpreter.\footnote{John Reynolds uses the term ``definitional interpreter'' to illustrate the same concepts~\cite{defint}.} The languages that we have been designing so far use the fancy $\mathcal{L}$ with a subscript serving as the name of the language (extension). Nested interpreters also use subscript identifiers, but include a superscript asterisk, i.e., $\mathcal{L}^{*}$. In essence, any and all code written for these languages is nested inside the C-written interpreter, hence its name.  

The nested interpreters that we will design throughout the rest of this book, in general, utilize two categorizations of functions: recognizers\index{reducer} and reducers\index{reducer}. A \textit{recognizer function}\index{recognizer function}, or recognition function\index{recognition function}, is a predicate that determines whether a given expression resembles a form. For example, to determine if an arbitrary s-expression is a prefixed binary addition operator, we can design the recognizer \ttt{add?}, which verifies that the s-expression is a list containing three elements, and its \textit{first} is the \ttt{\q{+}} symbol.

\begin{cl}[]{Example of \ttt{add?} Recognizer Function}
\begin{lstlisting}[language=MyScheme]
(define add?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 3)
       (eqv? (first exp) '+))))
\end{lstlisting}
\end{cl}

Every recognizer function has an accompanying reducer function that describes how to process or evaluate the form determined by the recognizer. In the \ttt{add} example, we may write the \ttt{value-of-add} reducer to add its two components together. Note that we often recursively evaluate components of a form via a root reduction dispatch function, such as \ttt{value-of}. We also extract the form components into local variables to aid in our discussion of the reducer.

\begin{cl}[]{Example of \ttt{value-of-add} Reducer Function}
\begin{lstlisting}[language=MyScheme]
(define value-of-add
 ((*;$\lambda$;*) (exp)
  (let ([lhs (value-of (second exp))]
        [rhs (value-of (third exp))])
   (+ lhs rhs))))
\end{lstlisting}
\end{cl}

Recognition and reduction functions go hand-in-hand, and we will generally combine them into one listing (frame) to condense the vertical space as necessary. Recognition functions will always have the name \ttt{$<$name?$>$} whereas reducers will always have the name \ttt{$<$value-of-name$>$}.

\clearpage
\subsection*{\nestedlang{INFIX}: An Infix Calculator}

A few chapters ago, we began our journey by exploring prefix arithmetic expressions. In this and subsequent sections, we will begin our journey of writing interpreters within our interpreter. Each interpreter will have a suffixed asterisk (*) to designate that it is a \textit{nested interpreter}. So, in this section, we will write \nestedlang{INFIX}\index{\nestedlang{INFIX}}: a language to parse simple binary infix expressions.

In the previous section, we implied that some readers may feel inclined to define three variables for the three components of an infix binary operator, those being the \texttt{lhs-rand}, \texttt{rator}, and \texttt{rhs-rand}. Interestingly enough, this is part of what we need to do in order to parse infix expressions. First, we have to be able to recognize a binary infix expression. A binary infix expression contains the three aforementioned components in a list, and the \texttt{rator} is a symbol. We can write a function, e.g., \texttt{binop?} to test if an expression is a binary infix expression. We will need to write a helper function, \texttt{length}, to compute the length of a list. We also need to write and define \texttt{second}, and \texttt{third} (which we will omit in the listings). All that is remaining is evaluation of a binary infix expression. Similar to those interpreters we have written in C, as a function application, we evaluate the arguments before applying. So, let us write a function, e.g., \texttt{value-of-binop}, which receives an expression and an environment, and evaluates the arguments then applies the respective binary operator. Following these additions, we should create a few relevant test cases.

\begin{clrr}[]{}\begin{lstlisting}[language=MyScheme]
(define binop?
 ((*;$\lambda$;*) (expr)
  (and (cons? expr) 
       (= (length expr) 3) 
       (symbol? (second expr)))))
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-binop
 ((*;$\lambda$;*) (expr env)
  (let ([lhs-rand (first expr)]
        [rator (second expr)]
        [rhs-rand (third expr)])
   ((value-of rator env)
    (value-of lhs-rand env)
    (value-of rhs-rand env)))))
\end{lstlisting}
\end{clrr}
\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of
 ((*;$\lambda$;*) (expr env)
  (cond
   [(number? expr) (value-of-number expr)]
   [(symbol? expr) (apply-env expr env)]
   [(binop? expr) (*;\textcolor{lightgray}{$\ldots$};*)]
   [else 'error])))
\end{lstlisting}\end{cl}

\begin{clo}[]{}
\begin{lstlisting}[language=MyScheme]
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(3 + 4) global-env)
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)((3 + 4) + (9 - 6)) global-env)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
7
10
\end{lstlisting}
\end{clo}

Is this not absolutely invigorating? We have written a series of (increasingly-difficult) interpreters in C, wherein the last one is now powerful enough that we can write an interpreter within the interpreter.

\exercise{5}{chapter-functional}{In many instances, infix expressions come across as intuitive to those of us who use them regularly compared to prefix, as we have demonstrated. Though, one downside of \nestedlang{INFIX} is its requirement of parentheses to force precedence and associativity. Modify \nestedlang{INFIX} to allow for expressions that use the following precedence and associativity rules: parenthesized expressions are evaluated first, then exponents, then multiplication/division, and finally addition/subtraction. Multiplication, division, addition, and subtraction are all left-associative, whereas exponents are right-associative. We present some test cases below.}

\begin{clo}[]{}
\begin{lstlisting}[language=MyScheme]
(*;\textbf{>};*) (value-of '(2 - 3 - 4 - 5) global-env)
(*;\textbf{>};*) (value-of '(2 * 4 + 3 * 5 - 9 * 8) global-env)
(*;\textbf{>};*) (value-of '(2 + 3 * 4 - 5) '() global-env)
(*;\textbf{>};*) (value-of '(1 + 2 + 3 + 4) '() global-env)
(*;\textbf{>};*) (value-of '(2 * 4 + 3 - 5 * 9) global-env)
(*;\textbf{>};*) (value-of '(2 * (4 * 7 + 5) * 9) global-env)
(*;\textbf{>};*) (value-of '(2 - (4 + 7 + 5) * 9) global-env)
(*;\textbf{>};*) (value-of '(2 * 4) global-env)
(*;\textbf{>};*) (value-of '(3 - 9 + 8 - 7 + 6) global-env)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
-10
-49
9
10
-34
594
-142
8
1
\end{lstlisting}
\end{clo}

Hint: write a \texttt{flatmap*} function that recursively applies a function $f$ to all sublists of a list $\textit{ls}$. Take the following invocations for examples of how this function might be used.

\begin{clonarrow}[]{``Flat Map'' Skeleton Code and Examples}
\begin{lstlisting}[language=MyScheme]
; A MaybeList is one of:
; - X
; - (cons X MaybeList)

;; flatmap : {X} {Y} [[ListOf X] -> Y] 
;; (*;\hspace{20.5ex};*) [ListOf [MaybeList X]] 
;; (*;\hspace{20.5ex};*) -> [ListOf Y]
;; Applies a function f over lists to a list potential 
;; lists. If an element is a sublist, it is flattened 
;; and f is applied to it. If an element is any other 
;; value, it is copied over to the resulting list.
(define flatmap*
 ((*;$\lambda$;*) (f ls)
  (cond
   [(null? ls) ___]
   [(cons? (first ls)) ___]
   [else ___])))

(*;\textbf{>};*) (flatmap* length '(1 (2) ((3)) (4 ((5 6 7)) 8)))
(*;\textbf{>};*) (flatmap* length '(((1 2) 3 (4 ((5) (6)) 7)) 8 9))
(*;\textbf{>};*) (flatmap* length '(1 (((((2 3 4 5) (6)))) 7) 8 9))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]


















(1 1 1 3)
(3 8 9)
(1 2 8 9)
\end{lstlisting}
\end{clonarrow}

\clearpage
\subsection*{\nestedlang{COND}: Booleans and Conditionals}

In this section we will extend \nestedlang{INFIX} to include boolean literals and conditionals via \texttt{if} in the \nestedlang{COND}\index{\nestedlang{COND}} language.

First, we need a way of recognizing boolean values. So, similar to numbers, we can simply add a clause in \texttt{value-of} that checks to see if a value is a boolean using the predefined predicate. Similar to the number and symbol counterparts, we do not need a recognizer for the primitive boolean type, meaning we just write its reducer.

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define value-of-boolean
 ((*;$\lambda$;*) (expr env)
  expr))
\end{lstlisting}
\end{cl}

After this addition to the root evaluation function, we can now evaluate boolean literals.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyScheme]
(*;\textbf{>};*) (value-of '#f global-env)
(*;\textbf{>};*) (value-of '#t global-env)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
#f
#t
\end{lstlisting}
\end{cloast}

Now that our nested interpreter understands boolean values, let us switch our interpreter to use prefixed expressions instead of infix. In doing this, we will want to redefine our arithmetic expressions. We shall create two procedures for evaluating addition and subtraction of arbitrary numbers. These expressions, therefore, will be of type ``add'' and ``sub'' respectively. Each expression consists of an operator and the two operands. Conveniently enough, both decision predicates are almost identical---the only distinction being the predicate name and the symbol to check. Let us also write two reducer functions for computing the value of addition and subtraction expressions. 

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define add?
 ((*;$\lambda$;*) (expr)
  (and (cons? expr)
       (= (length expr) 3)
       (eqv? (first expr) '+))))
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-add
 ((*;$\lambda$;*) (expr env)
  (let ([lhs-rand (second expr)]
        [rhs-rand (third expr)])
   (+ (value-of lhs-rand env)
      (value-of rhs-rand env)))))
\end{lstlisting}
\end{clrr}

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define sub?
 ((*;$\lambda$;*) (expr)
  (and (cons? expr)
       (= (length expr) 3)
       (eqv? (first expr) '-))))
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-sub
 ((*;$\lambda$;*) (expr env)
  (let ([lhs-rand (second expr)]
        [rhs-rand (third expr)])
   (- (value-of lhs-rand env)
      (value-of rhs-rand env)))))
\end{lstlisting}
\end{clrr}

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of
 ((*;$\lambda$;*) (expr env)
  (cond
   [(number? expr) (value-of-number expr env)]
   [(symbol? expr) (apply-env expr env)]
   [(boolean? expr) (value-of-boolean expr env)]
   [(add? expr) (value-of-add expr env)]
   [(sub? expr) (value-of-sub expr env)]
   [else 'error])))
\end{lstlisting}\end{cl}

\noindent Now, we can execute a few test cases.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyScheme]
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(- 10 3) global-env)
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(+ 2 3) global-env)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
7
5
\end{lstlisting}
\end{cloast}

With this, we can add a couple of special yet familiar procedures to our interpreter: \texttt{sub1}, \texttt{add1}, and \texttt{zero?}. Their recognition and reducer functions are similar to the binary \texttt{add} and \texttt{sub} functions.

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define zero?
 ((*;$\lambda$;*) (expr)
  (and (cons? expr)
       (= (length expr) 2)
       (eqv? (first expr) 'zero?))))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-zero
 ((*;$\lambda$;*) (expr env)
  (let ([rand (second expr)])
   (= (value-of rand env) 0))))
\end{lstlisting}
\end{clrr}

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define add1?
 ((*;$\lambda$;*) (expr)
  (and (cons? expr)
       (= (length expr) 2)
       (eqv? (first expr) 'add1))))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-add1
 ((*;$\lambda$;*) (expr env)
  (let ([rand (second expr)])
   (+ (value-of rand env) 1))))
\end{lstlisting}
\end{clrr}

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define sub1?
 ((*;$\lambda$;*) (expr)
  (and (cons? expr)
       (= (length expr) 2)
       (eqv? (first expr) 'sub1))))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-sub1
 ((*;$\lambda$;*) (expr env)
  (let ([rand (second expr)])
   (- (value-of rand env) 1))))
\end{lstlisting}
\end{clrr}

\noindent Now, all that is left is to add these forms to \texttt{value-of}.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of
 ((*;$\lambda$;*) (expr env)
  (cond
   [(number? expr) (value-of-number expr env)]
   [(symbol? expr) (apply-env expr env)]
   [(boolean? expr) (value-of-boolean expr env)]
   [(add1? expr) (value-of-add1 expr env)]
   [(sub1? expr) (value-of-sub1 expr env)]
   [(zero? expr) (value-of-zero expr env)]
   [(add? expr) (value-of-add expr env)]
   [(sub? expr) (value-of-sub expr env)]
   [else 'error])))
\end{lstlisting}\end{cl}

\noindent As always, let us test the modifications.

\begin{clonarrow}[]{}
\begin{lstlisting}[language=MyNLNScheme]
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(add1 (add1 (add1 (add1 (add1 0))))) 
             global-env)
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(+ (add1 (add1 10)) (sub1 9))
             global-env)
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(zero? 10)
             global-env)
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(zero? (sub1 (sub1 (sub1 (sub1 4)))))
             global-env)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
5

20

#f

#t
\end{lstlisting}
\end{clonarrow}

Next, we should add support for conditionals. This is simple enough---a conditional in \nestedlang{COND} takes the form of a list where the \textit{first} is \texttt{if}, the \textit{second} is the predicate to test, the \textit{third} is the consequent, and the \textit{fourth} is the alternative. As we did in \regularlang{COND3}, we first evaluate the predicate and, if it resolves to true, we evaluate the consequent. Otherwise, we evaluate the alternative.

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define if?
 ((*;$\lambda$;*) (expr)
  (and (cons? expr)
       (= (length expr) 4)
       (eqv? (first expr) 'if))))
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-if
 ((*;$\lambda$;*) (expr env)
  (let ([predicate (second expr)]
        [consequent (third expr)]
        [alternative (fourth expr)])
   (if (value-of predicate env)
       (value-of consequent env)
       (value-of alternative env)))))
\end{lstlisting}\end{clrr}

\noindent Now, once again, we test.

\begin{clonarrow}[]{}
\begin{lstlisting}[language=MySOutput]
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(if (zero? 0) (+ 5 5) (+ 10 10)) 
             global-env)
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(if (zero? (sub1 (sub1 (+ 1 2)))) 100 200) 
             global-env)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
10

200
\end{lstlisting}
\end{clonarrow}

\clearpage
\subsection*{\nestedlang{PROC}\index{\nestedlang{PROC}}: Procedures and Variables}

Because the interpreter is rather small, we will limit the scope of procedure and variable definitions by a considerable amount. We define this limit to be a super-set of the $\lambda$-calculus. For instance, our interpreter will be able to correctly evaluate the following expressions.

\begin{cl}[]{}\begin{lstlisting}[language=MyNLNSOutput]
(*;\textquotesingle;*)((lambda (x) x) 5)

(*;\textquotesingle;*)((lambda (x) (if (zero? x) 20 30)) 0)

(*;\textquotesingle;*)(let ([x 10]) (+ x 20))

(*;\textquotesingle;*)(let ([z 10]) (let ([y 500]) (if (zero? (- y y)) z (add1 z))))
\end{lstlisting}\end{cl}

So, this means our interpreter should understand lexically-scoped variables via one-binding \texttt{let} declarations, and one-argument lambda procedures. Implementing the former is a bit easier than the latter, so we will begin from there.

Recall, from Chapters~\ref{chapter-interpretation1} and~\ref{chapter-interpretation2}, the notion of environment extension. When we extend an environment $e_0$, we create a new environment $e_1$ which has a pointer to $e_0$ alongside any new variable bindings (i.e., $e_1\rightsquigarrow{e_0}$). So, when we create, for instance, a \texttt{let} binding, we create a new environment, then add the variable name and associated value to said environment. In our interpreter, we first want to recognize \texttt{let} expressions of one variable binding. A \texttt{let} expression has three components: the \texttt{let} symbol itself, a variable binding, and the body. Because we want our \texttt{let} declarations to mimic ones from our implementing language, the bindings are stored within a list of a list, e.g., \texttt{([x 10])}. Thus, the symbol to bind is the first of the first of the second, i.e., \texttt{x}, and the expression to evaluate, i.e., \texttt{10}, then bind to \texttt{x} is the second of the first of the second. A complete example is \texttt{(let ([x 10]) x)}. So, let us now write the code for evaluating a \texttt{let} expression. We need to evaluate the variable binding expression first, then use that evaluation in the body of the \texttt{let}. Furthermore, we need to extend the current environment to support the new variable binding.

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define let?
 ((*;$\lambda$;*) (expr)
  (and (cons? expr)
       (= (length expr) 3)
       (eqv? (first expr) 'let)
       (symbol? 
        (first 
         (first (second expr)))))))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-let
 ((*;$\lambda$;*) (expr env)
  (let* ([lobindings (second expr)]
         [binding (first lobindings)]
         [var (first expr)]
         [res-var (second expr)]
         [body (third expr)])
   (*;\textcolor{lightgray}{$\ldots$};*))))
\end{lstlisting}
\end{clrr}

We are going to go step-by-step to show exactly what is happening in this evaluation. We first extract the three components of the \texttt{let} declaration. Now, we need to evaluate the body in an environment that contains the new symbol. Remember that in Chapters~\ref{chapter-interpretation1} and ~\ref{chapter-interpretation2}, we introduced \texttt{extend-env}: a procedure to add a new symbol and expression to an environment \textit{as a new environment}. Extending the environment, as we have seen previously, returns a new environment with the appended symbol binding. 

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-let
 ((*;$\lambda$;*) (expr env)
  (let* ([lobindings (second expr)]
         [binding (first lobindings)]
         [var (first expr)]
         [res-var (second expr)]
         [body (third expr)])
   (value-of body (extend-env var (value-of res-var env) env)))))
\end{lstlisting}\end{cl}

Here's the deal: our environment, right now, uses an association list as its representation. Fortunately, our interpreter is already representation independent because there are no references to environments other than \texttt{apply-env} (which abstracts the code to find a symbol binding). The only thing that is left is to write \texttt{extend-env} and update \texttt{value-of}. We might also consider rewriting \texttt{global\_env} to use \texttt{extend-env} rather than relying on the non-representation-independent association list representation.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define extend-env
 ((*;$\lambda$;*) (x arg env)
  (cons (cons x arg) env)))

(define value-of
 ((*;$\lambda$;*) (expr env)
  (cond
   [(*;\textcolor{lightgray}{$\ldots$};*)]
   [(let? expr) (value-of-let expr env)]
   [(*;\textcolor{lightgray}{$\ldots$};*)])))
\end{lstlisting}\end{cl}

Let us see how the tests that use \texttt{let} fair with our changes.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(let ([x 10]) 
              (+ x 20))
            global-env)
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(let ([z 10]) 
              (let ([y 500]) 
               (if (zero? (- y y)) 
                   z 
                   (add1 z))))
            global-env)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
30


10
\end{lstlisting}
\end{cloast}

Awesome! Lexical bindings now work beautifully. Let us now tackle the monster that is lambda procedures (which is not actually a monster).

A \texttt{lambda} procedure has three components akin to \texttt{let}: the \texttt{lambda} symbol, a formal parameter as a list element, i.e., \texttt{(x)}, and the body. Let us write the code to determine if an arbitrary expression is a \texttt{lambda} expression.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define lambda?
 ((*;$\lambda$;*) (expr)
  (and (cons? expr)
       (= (length expr) 3)
       (eqv? (first expr) 'lambda)
       (symbol? (first (second expr))))))
\end{lstlisting}\end{cl}

Now, we need to write the code for evaluating a \texttt{lambda} expression. How do we do this? A \texttt{lambda} is a procedure, so it should certainly return one! In this procedure, once invoked, we evaluate the body with respect to the formal parameter. Thus, when the function is invoked, it receives one argument which is then bound, in a new environment, to the listed formal parameter. In the code listing, the argument passed to the \texttt{lambda} is \texttt{arg}, which is bound to the formal parameter specified by \texttt{param}.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-lambda
 ((*;$\lambda$;*) (expr env)
  (let* ([loparams (second expr)]
         [param (first loparams)]
         [body (third expr)])
   ((*;$\lambda$;*) (arg)
    (value-of body (extend-env param arg env))))))
\end{lstlisting}\end{cl}

Lastly, we must add function application. There is little use in having lambda functions without any way of invoking them somehow. A function application has two components represented as elements of a list: an operator, or ``rator'' for short, and an operand, or ``rand'' for short. A ``rator'' is either a symbol, a lambda function, or another application (notice the recursive definition). The former is only possible when said symbol is defined as a lambda procedure, e.g., in a lexical scoped environment, i.e., \texttt{let}. The ``rand'' can be any possible value, so long as it is a valid argument to the procedure.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define application?
 ((*;$\lambda$;*) (expr)
  (and (cons? expr)
       (= (length expr) 2)
       (or (symbol? (first expr))
           (lambda? (first expr))
           (application? (first expr))))))
\end{lstlisting}\end{cl}

Now to evaluate function applications. Fortunately, this component is significantly easier than the application step in the previous interpreters! All we need to do is evaluate both the ``rator'' and ``rand'', then invoke ``rator'' as a function with ``rand'' as its argument.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-application
 ((*;$\lambda$;*) (expr env)
  (let ([rator (first expr)]
        [rand (second expr)])
   ((value-of rator env) (value-of rand env)))))
\end{lstlisting}\end{cl}

\noindent Tying everything together gets us the following.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of
 ((*;$\lambda$;*) (expr env)
  (cond
   [(*;\textcolor{lightgray}{$\ldots$};*)]
   [(lambda? expr) (value-of-lambda expr env)]
   [(application? expr) (value-of-application expr env)]
   [(*;\textcolor{lightgray}{$\ldots$};*)])))
\end{lstlisting}\end{cl}

Let us see some test cases! To make things slightly more interesting, we added a binary multiplication operator to \nestedlang{PROC}.

\begin{clo}[]{}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)((lambda (x) x) 5) 
            global-env)
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)((lambda (x) (add1 x)) 5) 
            global-env)
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(let ([! (lambda (x) (* x x))])
              (let ([! (lambda (n)
                     (if (zero? n) 
                         1 
                         (* n (! (sub1 n)))))])
               (! 5))) 
            global-env)
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(let ([y (* 3 4)])
              ((lambda (x) (* x y)) (sub1 6)))
            global-env)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
5

6

60






80
\end{lstlisting}
\end{clo}

This mini-interpreter and \nestedlang{PROC} are now so powerful that they recognize and correctly evaluate recursive procedures. How amazing is that?

\subsubsection*{Representation Independence With Respect to Closures}

Our interpreter is representation-independent with respect to environments. That is, the interpreter calls the environment helper functions \texttt{apply-env}, \texttt{extend-env}, and \texttt{empty-env}. Using these functions instead of manipulating/accessing the environment directly allows us greater flexibility in our representation of the environment. At the moment, this is not the case for closures. Closures are created when we declare a lambda function, and are applied when invoking the function, i.e., \texttt{value-of-lambda} and \texttt{value-of-application} respectively. Our current interpreter assumes that closures use a functional representation; \texttt{value-of-lambda} returns a function, and \texttt{value-of-application} applies the evaluated operator onto its evaluated operand. An improved approach is to use representation-independent closures. In this short section, we will implement two helper functions to achieve this goal.

What functions do we need to get representation-independence with respect to closures? Well, there are only two cases in which closures are used: when they are created and when they are applied. So, we should aptly call these \texttt{create\_closure} and \texttt{apply\_closure} respectively. 

\texttt{create\_closure} receives two arguments: a body and an environment. It is up to the implementation of the closure to decide how it wants to represent the closure. For instance, we may choose to represent it using functions, as we currently do, or we may choose to use a data-structural representation such as a tagged list. To showcase the differences between the two, we shall implement closures with tagged lists. Let us begin by writing the function stub.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define create-closure
 ((*;$\lambda$;*) (body env)
  (*;\textcolor{lightgray}{$\ldots$};*)))
\end{lstlisting}\end{cl}

Because we choose to represent closures as tagged lists, we create a list whose first element (\textit{first}) is \texttt{\textquotesingle{}create-closure}, whose second element (\textit{second}) is the formal parameter to the closure, whose third element (\textit{third}) is the body to evaluate, and whose fourth element (\textit{fourth}) is the environment to evaluate the closure within. Handily, this is easily doable with quasiquotes.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define create-closure
 ((*;$\lambda$;*) (x body env)
  (*;\textasciigrave;*)(create-closure ,x ,body ,env)))
\end{lstlisting}\end{cl}

Now, the ``true'' wizardry is upon us with \texttt{apply-closure}. \texttt{apply-closure} receives an operator and an operand. By definition, the operator must be a \texttt{create-closure} tagged list. Before, the operator must have been a function since we were using a non-representation-independent, functional representation of closures. So, we can extract out the values from the tagged list using a \texttt{let}, then evaluate the body with respect to its extended environment. Recall that we have to bind the formal parameter \texttt{x} to the operand passed to \texttt{apply-closure}.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define apply-closure
 ((*;$\lambda$;*) (rator rand)
  (let ([x (second rator)]
        [body (third rator)]
        [env (fourth rator)])
   (value-of body (extend-env x rand env)))))
\end{lstlisting}\end{cl}

Remember the whole motivation behind representation independence: it is not the job of the interpreter to know \textit{how} we choose to implement environments or closures. That is, it sees these structures as black boxes, accessible or mutable through the helper functions. Therefore, if we decide to change the representation of one or both structures, the interpreter works the same (assuming we correctly implement the underlying representation, of course!). Let us finally add these two functions to the interpreter to make it truly representation-independent. The only two functions we need to update are \texttt{value-of-lambda} and \texttt{value-of-application}. After doing so, the previous tests should work as expected.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-lambda
 ((*;$\lambda$;*) (expr env)
  (let* ([loparam (second expr)]
         [param (first loparam)]
         [body (third expr)])
   (create-closure param body env))))

(define value-of-application
 ((*;$\lambda$;*) (expr env)
  (let ([rator (first expr)]
        [rand (second expr)])
   (apply-closure rator rand))))
\end{lstlisting}\end{cl}

\subsubsection*{Lexical Scoping Implementation}

The previous nested interpreter added local bindings via \texttt{let}. Because we continuously pass the environment inside to the expression body, these bindings use lexical scoping\index{lexical scoping}. If we want to add recursive bindings via \texttt{letrec}, we need to amend our interpreter to explicitly use lexical scoping wherein we return the environment used in the evaluation of an arbitrary expression. This translation propagates through the entire interpreter. So, to pass two values as the result of some evaluation, we use a \textit{cons} pair. Returning pairs from an expression is nothing new, but it is significantly more convenient to update our representation of both closures and environments to work with a similar representation. Closures use a functional representation whereas environments use association lists. We will convert both to use a tagged list representation. Tagged lists are data whose \textit{first} is some identifying ``tag'', or symbol, denoting the purpose of the list contents. So, in particular, we need to update our definition of \texttt{apply-env} to recognize each environment tag and perform the appropriate dispatch. Closures, conveniently, are somewhat simpler compared to their functional counterparts, omitting the need for the additional lambda expression to check for the argument to the closure.

\begin{cl}[]{Tagged List Representation for Closures and Environments}
\begin{lstlisting}[language=MyScheme]
(define empty-env
 ((*;$\lambda$;*) ()
  (*;\textasciigrave;*)(empty-env)))

(define extend-env
 ((*;$\lambda$;*) (x arg env)
  (*;\textasciigrave;*)(extend-env ,x ,arg ,env)))

(define apply-env
 ((*;$\lambda$;*) (y env)
  (let ([tag (first env)])
   (cond
    [(eqv? tag 'empty-env) 'unknown-identifier]
    [(eqv? tag 'extend-env)
     (let ([x (second env)] 
           [arg (third env)] 
           [env^ (fourth env)])
      (cond
       [(eqv? y x) arg]
       [else (apply-env y env^)]))]
    [else #f]))))

(define make-closure
 ((*;$\lambda$;*) (x body env)
  (*;\textasciigrave;*)(make-closure ,x ,body ,env)))

(define apply-closure
 ((*;$\lambda$;*) (rator rand env)
  (let ([tag (first rator)])
   (cond
    [(eqv? tag 'make-closure)
     (let ([x (second rator)] 
           [body (third rator)] 
           [env^ (fourth rator)])
      (value-of body (extend-env x rand env^)))]
    [else #f]))))
\end{lstlisting}
\end{cl}

Now, in the (interpreter) reducer functions, we need to update each place where we return a value to return a \textit{cons} pair whose \textit{first} is the evaluated expression and whose \textit{rest} is the environment in which that expression was evaluated. For certain expressions that recursively call \texttt{value-of}, there is no need to wrap it in such a pair because the resulting expression is \textit{already} wrapped. It is also important to account for the fact that each call to \texttt{value-of} will return a pair, meaning that in cases where said value is significant, e.g., when evaluating \texttt{(+ x y)}, \texttt{x} and \texttt{y} are extracted out and used in the subsequent pair. In most cases, the lexically-scoped environment returned is irrelevant, meaning we will omit its extraction. Moreover, because many of these changes are purely mechanical, we will only show a couple of recognizer/reducer pairs.

\begin{cl}[]{Lexically-Scopifying Our Interpreter}
\begin{lstlisting}[language=MyScheme]
(define value-of-number
 ((*;$\lambda$;*) (exp env)
  (let ([n exp])
   (*;\textasciigrave;*)(,n . ,env))))

(define value-of-zero?
 ((*;$\lambda$;*) (exp env)
  (let ([n (second exp)])
   (let* ([pair-n (value-of n env)] [res-of-n (first pair-n)])
    (*;\textasciigrave;*)(,(= res-of-n 0) . ,env)))))

(define value-of-mul
 ((*;$\lambda$;*) (exp env)
  (let ([x (second exp)] [y (third exp)])
   (let* ([pair-x (value-of x env)] [res-of-x (first pair-x)]
          [pair-y (value-of y env)] [res-of-y (first pair-y)]) 
    (*;\textasciigrave;*)(,(* res-of-x res-of-y) . ,env)))))

(define value-of-if
 ((*;$\lambda$;*) (exp env)
  (let ([p (second exp)] [c (third exp)] [a (fourth exp)])
   (let* ([pair-p (value-of p env)] [res-of-p (first pair-p)])
    (if res-of-p
        (value-of c env)
        (value-of a env))))))

(define value-of-let
 ((*;$\lambda$;*) (exp env)
  (let ([x (first (first (second exp)))] [binding (second (first (second exp)))] [body (third exp)])
   (let* ([pair-binding (value-of binding env)] 
          [res-of-binding (first pair-binding)])
    (value-of body (extend-env x res-of-binding env))))))
\end{lstlisting}
\end{cl}

We can throw a few tests at the updated to show its changes. Doing so demonstrates that our result is, of course, a pair. To get the result, all we would need to do is retrieve the \textit{first}. Additionally, we see the tagged list representation in action.\footnote{Some may question the lack of parentheses upon invoking \texttt{extend-env} for the first time in the tagged list representation. This is because of how we print lists--if the list generated by \texttt{extend-env} ends in the empty list, which it does, then it is treated as \textit{cons}'ing onto a \textit{cons} cell, thus removing parentheses.}

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (value-of '5 
            (empty-env))
            
(*;\textbf{>};*) (value-of '(lambda (x) 
              (lambda (y) 
               (+ x y))) 
            (empty-env))
            
(*;\textbf{>};*) (value-of '(((lambda (x) 
                (lambda (y) 
                 (+ x y))) 
                   5) 
                  6)              
            (empty-env))
            
(*;\textbf{>};*) (value-of '(let ([add 
                    (lambda (x) 
                     (lambda (y) 
                      (+ x y)))]) 
              ((add 5) 10)) 
            (empty-env))
            
(*;\textbf{>};*) (value-of 
 '(let ([f (lambda (x) x)])
   (let ([g (lambda (y) (+ (f y) 3))])
    (let ([f (lambda (z) (+ 3 z))])
     (g 3))))
 (empty-env))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
'(5 empty-env)


'((make-closure x 
   (lambda (y) (+ x y)) 
   (empty-env)) 
  empty-env)
  
'(11 extend-env y 6 
  (extend-env x 5 (empty-env)))




  
'(15 extend-env y 10 
  (extend-env x 5 (empty-env)))




  
'(6 extend-env y 3 
  (extend-env 
   f 
   (make-closure x x (empty-env)) 
   (empty-env)))
\end{lstlisting}
\end{cloast}

With this brief detour put to bed, we can now implement \texttt{letrec} into our system. This version of \texttt{letrec} is harder than the one we defined at the interpreter (C) level because we do not have side-effects in our language. That form of \texttt{letrec} declared all variable identifiers in an environment prior to evaluating their respective bindings. As each binding was ``uncovered'', so to speak, its respective value was changed in the environment via \texttt{environment-set!}. We have no such environment alteration capabilities, so we will need another approach. A not-very-well-known but classic method is through ``half-closures''. Closures, as we know, store an expression to evaluate and the environment in which it was created. The problem with \texttt{letrec} is that a binding is allowed to be recursive, meaning that an identifier is referenceable within the binding. Consider the following definition of factorial that uses \texttt{letrec}. Note that this code is, at the moment, only executable outside the nested interpreter.

\begin{clo}[]{Implementation of Factorial using \texttt{letrec}}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (letrec ([! 
            ((*;$\lambda$;*) (n)
             (if (zero? n) 
                 1 
                 (* n (! (sub1 n)))))])
   (! 5))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
120
\end{lstlisting}
\end{clo}

We somehow need a way of telling our interpreter that \texttt{letrec} contains an identifier whose binding is referenced only when it (i.e., the identifier) is referenced. 

So, let us first add the recognizer, reducer, and clause to the interpreter for \texttt{letrec} expressions. The magic comes not from any of these, but in fact from \texttt{apply-env} which we will amend shortly. In writing the corresponding reducer function, we need to communicate to \texttt{apply-env} that the environment passed to the \texttt{letrec} body evaluation is special since it contains a half-closure. Thus, we will write a \texttt{make-letrec-env} function that has a unique tag identifier. 

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define make-letrec-env
 ((*;$\lambda$;*) (1/2-closure env)
  (*;\textasciigrave;*)(letrec-env ,1/2-closure ,env)))

(define letrec?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 3)
       (eqv? (first exp) 'letrec))))
        
(define value-of-letrec
 ((*;$\lambda$;*) (exp env)
  (let ([1/2-closure (second exp)] [body (third exp)])
   (value-of body (make-letrec-env 1/2-closure env)))))

(define value-of
 ((*;$\lambda$;*) (exp env)
  (cond
   [(*;\textcolor{lightgray}{$\ldots$};*)]
   [(letrec? exp) (value-of-letrec exp env)]
   [(application? exp) (value-of-application exp env)]
   [else 'error])))
\end{lstlisting}
\end{cl}

As we said, the heart of the logic lies within \texttt{apply-env}. It encompasses three (meaningful) clauses: \texttt{empty-env}, \texttt{extend-env}, and now \texttt{letrec-env}. We first extract the necessary fields from the tagged list. We then retrieve the binding associated with the identifier in the half-closure using \texttt{assv} and \texttt{second}. This binding is evaluated with respect to the environment referenced by \texttt{y}. Again, because this result is a \textit{cons} value/environment pair, we return the result defined by its \textit{first}.

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define apply-env
 ((*;$\lambda$;*) (y env)
  (let ([tag (first env)])
   (cond
    [(*;\textcolor{lightgray}{$\ldots$};*)]
    [(eqv? tag 'letrec-env)
     (let* ([1/2-closure (second env)] [env^ (third env)])
      (let* ([p (assv y 1/2-closure)] 
             [1/2-closure-binding (second p)] 
             [pair-1/2-closure (value-of 1/2-closure-binding env)]
             [res-of-1/2-closure (first pair-1/2-closure)])
       res-of-1/2-closure))]
    [else #f])))
\end{lstlisting}
\end{cl}

This modification allows us to evaluate the \texttt{!} expression from before in our nested interpreter.

\begin{clo}[]{}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (value-of
   '(letrec ([! 
              (lambda (n)
               (if (zero? n) 
                   1 
                   (* n (! (sub1 n)))))])
     (! 5))
   (empty-env))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
120
\end{lstlisting}
\end{clo}

On the other hand, suppose that the half-closure binding is not used recursively. These instances inherently question the use of letrec in the first place. Regardless, our interpreter should appropriately handle such cases as if they were recursive. If we, for example, declare an identifier \texttt{num} to bind the expression \texttt{10}, the half-closure is \texttt{((num 10))}. Whenever we reference \texttt{num} in the body of our \texttt{letrec}, we invoke \texttt{apply-env} to see that, of course, the corresponding environment is tagged as \texttt{make-letrec-env}. From there, we evaluate the bound expression with respect to this environment to see that its value is not a closure, but instead a constant paired with a ``\texttt{letrec} environment''. Note that this idea propagates to defining functions that are not recursive in a \texttt{letrec} environment; the only difference is that instead of a constant being returned from the environment, a closure is returned that is simply not called within its body.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (value-of
   '(letrec ([num 10])
     (+ num num))
 (empty-env))
(*;\textbf{>};*) (value-of
   '(letrec ([even?
              (lambda (n)
               (zero? 
                (remainder n 2)))])
     (even? 71))
   (empty-env))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
'(20 
  letrec-env ((num 10)) (empty-env))


'(#f extend-env n 71 
  (letrec-env 
   ((even? 
    (lambda (n) 
     (zero? 
      (remainder n 2))))) 
   (empty-env)))
\end{lstlisting}
\end{cloast}

\clearpage
\subsection*{\nestedlang{LOOP}: Iteration Through Obscured Recursion}

In this section, we will write \nestedlang{LOOP}\index{\nestedlang{LOOP}}: an extension to \nestedlang{PROC} that adds a ``non-recursive'' loop to our language. We say ``non-recursive'' with quotes because the implementing language, i.e., \nestedlang{LOOP} will use recursion to emulate the loop. In essence, \nestedlang{LOOP} abstracts the recursion away from the programmer.

In Chapter~\ref{chapter-nonfunctional}, we will explore loops in greater detail in the non-nested interpreter. For the moment, in this section, we will add a special form to our nested interpreter called \texttt{do}. As a look-ahead, the \texttt{do} form in non-functional chapter is significantly easier to digest than the one we are about to implement simply because the capability of our form is limited by our language ``toolset''. 

A \texttt{do} loop is represented as a list with four elements: the first (\textit{first}) is the symbol \texttt{do}, the second (\textit{second}) is a condition $c$, the third (\textit{third}) is a ``step expression'' $s$, and the last (\textit{fourth}) is the body to evaluate. The \texttt{do} loop executes the body until $c$ is false. Each time the loop repeats, we evaluate three expressions in the following order: $c$, $s$, and the body. If $c$ is false, neither $s$ nor the body are evaluated. Programming languages with explicit iteration statements, e.g., C, introduce ``side-effects'', because the last component of a \texttt{for} loop, in most instances, modifies the value of a variable directly. As an example, consider the following loop in C:

\begin{cl}[]{}\begin{lstlisting}[language=MyC]
for (int i = 10; i > 0; i--) { (*;\textcolor{lightgray}{$\ldots$};*) }
\end{lstlisting}\end{cl} 

The body of this \texttt{for} loop is irrelevant and is, therefore, grayed out by ellipses. Rather, focus on the last component: \texttt{i--}. Such an expression decrements the value of \texttt{i} by one, then stores it back into \texttt{i}. Because we modify the state of \texttt{i}, we say that the loop has a side-effect. Our language, in its current state, does not have side-effects, so we need to circumvent the problem of explicit variable updates. A simple and effective solution is to shadow variables. Suppose we have the following code:

\begin{cl}[]{}\begin{lstlisting}[language=MyNLNSOutput]
(value-of (*;\textquotesingle;*)(let ([i 10])
            (do [(zero? i) 0]
                (- i 1)
                (display i))) 
          global-env)
\end{lstlisting}\end{cl}

Notice that we specify four components: the variable declaration, the condition, step, and the loop body expressions. 
First off, the condition consists of two sub-components: the condition to continue iteration, and the terminating expression. Before executing the loop body, we first evaluate the \texttt{if} which, correspondingly, checks to see if \texttt{i} is zero. When \texttt{i} finally reaches zero, the \texttt{do} expression resolves to the terminating expression, which in this instance is \texttt{0}. 
The step expression says that, each time the body of the loop is executed, we decrement \texttt{i} by one. Again, we cannot directly mutate the value of \texttt{i}. So, what we can do is add \texttt{i} with its new value, namely \texttt{i-1}, to the environment, then pass it forward to subsequent expression evaluations.\footnote{This code example also integrates \texttt{display} which calls the built-in \texttt{display} function. We omit its implementation due to its simplicity. In essence, all it does is calls \ttt{sval\_tostring} on the given argument.} Finally, we evaluate the body of the \texttt{do} expression.

Let us get to work! We must start by writing the code to recognize, or parse, a \texttt{do} expression. Again, the first (\textit{first}) is the \texttt{do} symbol, the second (\textit{second}) is an expression which resolves to true or false, the third (\textit{third}) is an expression that alters the value of some symbol, and the last (\textit{fourth}) is the do-body. Revisiting the expression extracted by \textit{third}, when we say it ``alters the value of some symbol'', we restrict the possibilities of said expression. Namely, the expression should be a binary operator where the first operand is a symbol and the second is an arbitrary expression. E.g., \texttt{(+ i 1)}, \texttt{(- i 1)}, and so on.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define do?
 ((*;$\lambda$;*) (expr)
  (and (cons? expr)
       (= (length expr) 4)
       (eqv? (first expr) 'do)
       (symbol? (sthird expr)))))
\end{lstlisting}\end{cl}

The last expression in the \texttt{and} chain may look a bit complex, but tracing through a simple \texttt{do} expression will hopefully reduce any induced stress. Now, let us write the accompanying \texttt{value-of-do}. Be warned that this function is more complicated than any form we have seen so far, so we need to take it one step at a time. 
To start, let us extract the four components from the expression: the condition, the terminating expression, the step, and the body. Then, we certainly need a \texttt{letrec} to simulate the iteration. Within the \texttt{letrec}, we declare a function \texttt{repeat} that is invoked as long as \texttt{condition} resolves to true.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-do
 ((*;$\lambda$;*) (expr env)
  (let* ([locondition (second expr)]
         [condition (first locondition)]
         [term (second locondition)]
         [step (third expr)]
         [body (fourth expr)])
   (letrec ([repeat 
             ((*;$\lambda$;*) ((*;\textcolor{lightgray}{$\ldots$};*)) 
              (*;\textcolor{lightgray}{$\ldots$};*))])
    (repeat (*;\textcolor{lightgray}{$\ldots$};*))))))
\end{lstlisting}\end{cl}

So, what should we pass to \texttt{repeat}? Recall the intended behavior of \texttt{do}: evaluate the condition expression, and as long as it is true, evaluate the body and extend the environment to include the updated step value. If the condition is false, return the terminating expression. So, to keep track of the extended environment, we should pass it as an argument to \texttt{repeat}. But recall that we also want to evaluate the body of the loop. Since we are only allowed one expression in the body of a lambda, we should wrap the invocation of evaluating the body into the recursive call as an argument.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-do
 ((*;$\lambda$;*) (expr env)
  (let* ([locondition (second expr)]
         [condition (first locondition)]
         [term (second locondition)]
         [step (third expr)]
         [body (fourth expr)])
   (letrec ([repeat 
             ((*;$\lambda$;*) (prev-expr prev-env) 
              (*;\textcolor{lightgray}{$\ldots$};*))])
    (repeat body env)))))
\end{lstlisting}\end{cl}

What is next? We evaluate the condition expression and when it is true, invoke \texttt{repeat} with an evaluated body and extended environment.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-do
 ((*;$\lambda$;*) (expr env)
  (let* ([locondition (second expr)]
         [condition (first locondition)]
         [term (second locondition)]
         [step (third expr)]
         [body (fourth expr)])
   (letrec ([repeat 
             ((*;$\lambda$;*) (prev-expr prev-env)
              (cond
               [(value-of condition prev-env)
                (repeat 
                 (value-of body prev-env)
                 (extend-env (second step) (value-of step prev-env) prev-env))]
               [else term]))])
    (repeat body env)))))
\end{lstlisting}\end{cl}

When extending the environment, we have a couple of guarantees. The first is that \texttt{step} is a list. The second is that \texttt{step} is represented as a binary operator application where the first operand is a symbol. So, we can extract the symbol with \texttt{second}, evaluate the step expression, then store this result into the new environment. This is passed along to the recursive call to \texttt{repeat} for subsequent evaluations. Let us try out the \texttt{do} loop from the preceding example.

\begin{clo}[]{}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (value-of (*;\textquotesingle;*)(let ([i 10])
              (do [(if (zero? i) #f #t) 0]
                  (- i 1)
                  (display i))) 
            global-env)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
109876543210
\end{lstlisting}
\end{clo}

As expected, the loop body outputs the numbers in decreasing order from ten down to one. Then, the loop resolves to \texttt{0} once the provided condition is false.

\clearpage
\subsection*{\nestedlang{LOGIC}: A Logical Formula Interpreter}

In Chapter~\ref{chapter-maths}, we introduced propositional logic, namely logical connectives, atoms, satisfiability, and proofs. In this section, we will write \nestedlang{LOGIC}\index{\nestedlang{LOGIC}}: a nested interpreter to parse and evaluate propositional logical expressions.

As a refresher, a propositional logic formula contains connectives and atoms. These connectives include logical conjunction, disjunction, implication, equivalence, and negation. Our connectives will take the form of tagged lists, where the tag is a connective identifier, and the rest of the elements represent propositional formulas. Additionally, atoms will also be tagged lists where the tag is \texttt{atom}. Let us look at a few examples.

\begin{cl}[]{}\begin{lstlisting}[language=MySOutput]
((*;\textbf{\textcolor{blue}{define}};*) p1 (*;\textasciigrave;*)(atom p))
((*;\textbf{\textcolor{blue}{define}};*) p2 (*;\textasciigrave;*)(atom q))
(*;\textasciigrave;*)(and ,p1 ,p2)
(*;\textasciigrave;*)(or ,p1 (atom r))
(*;\textasciigrave;*)(imp ,p2 (not (atom p)))
(*;\textasciigrave;*)(iff (not (and ,p1 ,p2)) 
      (imp (not ,p2) (not ,p1)))
\end{lstlisting}\end{cl}

Right now, these formulas are not very interesting because there are no associated truth values. In our previous interpreters, we used environments to store the corresponding values of symbols. In this language, environments will store either \texttt{\#t} or \texttt{\#f} to each atom as an association list. E.g., suppose we define an environment \texttt{env} as follows.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define env (*;\textasciigrave;*)((p . #t) (q . #f) (r . #f)))
\end{lstlisting}\end{cl}

Let us begin! We will first create the data definition for a schema. Then, we can write the basic evaluator and make the implementation representation-independent. 

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
; An AtomSchema is an 'atom

; A UnaryConnective is a 'not

; A BinaryConnective is one of:
; - 'and
; - 'or
; - 'imp
; - 'iff

; A Schema is one of:
; - (ListOf AtomSchema Atom)
; - (ListOf UnaryConnective Schema)
; - (ListOf BinaryConnective Schema Schema)

;; value-of : Schema Environment -> Schema
;; Evaluates a zeroth-order logic schema according to an
;; assignment of truth values in the environment.
(define value-of
 ((*;$\lambda$;*) (exp env)
  ((*;\textcolor{lightgray}{$\ldots$};*))))
\end{lstlisting}\end{cl}

Each logical connective needs a recognition predicate as well as an evaluation procedure. We can go ahead and fill the gaps inside \texttt{value-of} to streamline our design.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of
 ((*;$\lambda$;*) (exp env)
  (cond
   [(negation? exp) (value-of-negation exp env)]
   [(conjunction? exp) (value-of-conjunction exp env)]
   [(disjunction? exp) (value-of-disjunction exp env)]
   [(implication? exp) (value-of-implication exp env)]
   [(biconditional? exp) (value-of-biconditional exp env)]
   [else 'error])))
\end{lstlisting}\end{cl}

Now let us write the recognition predicates. Again, all we need to do is verify the number of operands and the list tag. Each recognition predicate is almost identical to one another; the only difference being the tag and required list length. After this, we evaluate each of the five connectives according to their logical rules.

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define negation?
 ((*;$\lambda$;*) (exp)
  (and (eqv? (first exp) 'not)
       (= (length exp) 2))))
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-negation
 ((*;$\lambda$;*) (exp env)
  (let 
   ([vexp (value-of (second exp) env)])
   (if vexp #f #t))))
\end{lstlisting}
\end{clrr}

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define conjunction?
 ((*;$\lambda$;*) (exp)
  (and (eqv? (first exp) 'and)
       (= (length exp) 3))))
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-conjunction
 ((*;$\lambda$;*) (exp env)
  (let* 
   ([lhs (value-of (second exp) env)]
    [rhs (value-of (third exp) env)])
   (and lhs rhs))))
\end{lstlisting}
\end{clrr}

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define disjunction?
 ((*;$\lambda$;*) (exp)
  (and (eqv? (first exp) 'or)
       (= (length exp) 3))))
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-disjunction
 ((*;$\lambda$;*) (exp env)
  (let* 
   ([lhs (value-of (second exp) env)]
    [rhs (value-of (third exp) env)])
   (or lhs rhs))))
\end{lstlisting}
\end{clrr}

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define implication?
 ((*;$\lambda$;*) (exp)
  (and (eqv? (first exp) 'imp)
       (= (length exp) 3))))
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-implication
 ((*;$\lambda$;*) (exp env)
  (let* 
   ([lhs (value-of (second exp) env)]
    [rhs (value-of (third exp) env)])
   (or (not lhs) rhs))))
\end{lstlisting}
\end{clrr}

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define biconditional?
 ((*;$\lambda$;*) (exp)
  (and (eqv? (first exp) 'iff)
       (= (length exp) 3))))
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-biconditional
 ((*;$\lambda$;*) (exp env)
  (let* 
   ([lhs (value-of (second exp) env)]
    [rhs (value-of (third exp) env)])
   (eqv? lhs rhs))))
\end{lstlisting}
\end{clrr}

Notice that we recursively evaluate the operands before applying the ``connective'' as the operator. Now, the only remaining pieces of the puzzle are \texttt{atom?}, \texttt{value-of-atom}, and \texttt{lookup}. The former reducer simply invokes \texttt{lookup} on the atom symbol (which is represented as \texttt{(second exp)}, whereas the latter traverses through the environment to find the corresponding truth value.

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define atom?
 ((*;$\lambda$;*) (exp)
  (and (eqv? (first exp) 'atom)
       (= (length exp) 2))))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-atom
 ((*;$\lambda$;*) (exp env)
  (let ([aexp (second exp)])
   (apply-env aexp env))))
\end{lstlisting}
\end{clrr}

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define lookup
 ((*;$\lambda$;*) (y env)
  (let ([binding (first env)])
   (cond
    [(eqv? (first binding) y) (rest binding)]
    [else (lookup y (rest env))]))))
\end{lstlisting}\end{cl}

\noindent Last but certainly not least, we need some test cases!

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (value-of 
   (*;\textquotesingle;*)(atom q) 
   (*;\textquotesingle;*)((p . #t) (q . #t)))
(*;\textbf{>};*) (value-of 
   (*;\textquotesingle;*)(and (atom p) (atom q)) 
   (*;\textquotesingle;*)((p . #t) (q . #t)))
(*;\textbf{>};*) (value-of 
   (*;\textquotesingle;*)(and (or (atom p) (not (atom q))) 
         (not (atom r))) 
   (*;\textquotesingle;*)((p . #f) (q . #f) (r . #t))) 
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
#t


#t


#t
\end{lstlisting}
\end{cloast}

So, we can use this interpreter to parse simple propositional logic formulas! Let us make it representation-independent with respect to environments. Fortunately, we only need one helper function: \texttt{apply-env}. Because it is impossible to add new atoms to a formula after the start of evaluation, we need not extend the environment.

\clearpage
\subsection*{\nestedlang{CNF}: Conjunctive Normal Form Constructor}
Continuing with the trend of formal logic, in this section we will write \nestedlang{CNF}\index{\nestedlang{CNF}}: an interpreter for converting propositional logic formulas into conjunctive normal form.

Let us start off with some definitions before proceeding into a discussion on the importance of conjunctive normal form schemata. A propositional logic schema $S$ is in \textit{conjunctive normal form}\index{conjunctive normal form}, or CNF\index{CNF}, if and only if it is a conjunction of disjunctive sub-schemata, composed of only simple schemata, i.e., negated or non-negated atoms.

\begin{figure}[H]
\begin{center}
\setlength{\fboxsep}{.5em}
\noindent\fbox{%
    \parbox{\textwidth - 6.5cm}{%
        \begin{align*}
            &`p\;\land\;(q\;\lor\;r)\text{'}\\
            &`\lnot{q}\text{'}\\
            &`((\lnot{p}\;\lor\;\lnot{q})\;\lor\;\lnot{r})\;\land\;(p\;\lor\;(\lnot{q}\;\lor\;\lnot{r}))\text{'}
        \end{align*}
    }%
}
\end{center}
\caption{Examples of Schemata in CNF}
\end{figure}

A schema in CNF cannot contain any connective other than logical conjunction, disjunction, and negation. A schema $S$ is a $k$-CNF schema if each sub-schema $S'$ contains $k$ simple schemata. As an example, the previous schema `$((\lnot{p}\;\lor\;\lnot{q})\;\lor\;\lnot{r})\;\land\;(p\;\lor\;(\lnot{q}\;\lor\;\lnot{r}))$' has two sub-schemata as operands of the (main operator) conjunction: `$((\lnot{p}\;\lor\;\lnot{q})\;\lor\;\lnot{r})$' and `$(p\;\lor\;(\lnot{q}\;\lor\;\lnot{r}))$'. The former of these schemata is comprised of the sub-schemata `$\lnot{p}$', `$\lnot{q}$', and `$\lnot{r}$', all of which are only (negated) atoms. Similarly, the latter of these schemata is comprised of the sub-schemata `$p$', `$\lnot{q}$', and `$\lnot{r}$', all of which are only (negated) atoms. Moreover, these sub-schemata each have three simple schemata as operands. Therefore if we assume that we only have $p$, $q$, and $r$ as propositional letters in our language, this is a $3$-CNF schema. 

Why do we even care about conjunctive normal form? Every propositional logic schema can be converted into an equivalent CNF. is useful for reducing the complexity and size of logic circuitry, as it relates to propositional logic. Standardizing, or normalizing, a representation for schemata helps quickly test software that rely on boolean schemata. Moreover, boolean satisfiability is a fundamental computer science problem, and converting a schema into its CNF equivalent allows us to quickly determine a falsifying assignment (should one exist). To do so, we look at an arbitrary clause of a CNF schema and assign $\bot$ to all negated atoms and $\top$ to all non-negated atoms. Because every conjunct of a CNF schema must be true for the overarching schema to be true, a falsifying interpretation of a conjunct falsifies the overarching schema (missing atoms from the sub-schema can be assigned arbitrary values). 

\example{Determine a falsifying truth value assignment for the CNF schema `$(p\;\lor\;\lnot{r})\;\land\;(\lnot{q}\;\lor\;\lnot{p})$'.} First we pick a schema at random and assign truth values using the aforementioned rules. Let `$p$'=$\bot$ and `$\lnot{r}$'$=\top$. Thus, `$(\bot\;\lor\;\bot)$' resolves to $\bot$. Because `$q$' is not at all used in the sub-schema, we can say that there are at least two falsifying assignments: `$p$'=$\bot$, `$q$'=$\top$, `$r$'$=\bot$, and `$p$'=$\bot$, `$q$'=$\bot$, `$r$'$=\bot$. So we quickly conclude that this schema is \textit{not} a tautology.

Interestingly, a schema that is in full-CNF may be quickly assessed for satisfiability. A schema is in \textit{full-CNF} if it is in $k$-CNF where $k$ is equal to the number of atoms in the language. A full-CNF schema $S$ is a \textit{tautology} if there are $2^{k}$ clauses, meaning every possible (truth value) interpretation is a clause in the full-CNF schema. A full-CNF schema $S$ is \textit{unsatisfiable} if, after removing logically-contradicting schemata from the conjunction, the schema is empty. A full-CNF schema $S$ is \textit{satisfiable} if it is not unsatisfiable.

\example{Determine if the full-CNF schema `$((\lnot{p}\;\lor\;\lnot{q})\;\lor\;\lnot{r})\;\land\;(p\;\lor\;(\lnot{q}\;\lor\;\lnot{r}))$' is satisfiable, assuming a language containing the atoms `$p$, `$q$', and '$r$'.} Because the schema contains no logical contradictions, there are no schemata to remove. Therefore this schema is satisfiable.

With the theory background taken care of, let us write a nested interpreter! Not quite, because we need to implement the conversion procedure! Given a schema, we convert it to CNF using the following steps (not necessarily in this order):

\setlength{\fboxsep}{.5em}
\noindent\fbox{%
    \parbox{\textwidth - .5cm}{%
        \begin{enumerate}
            \item Remove all conditionals, i.e., `$p \to q$' converts into `$\lnot{p} \;\lor\;q$'.
            \item Remove all biconditionals, i.e,. `$p \leftrightarrow q$' converts into `$(p\;\land\;q)\;\lor\;(\lnot{p}\;\land\;\lnot{q})$'.
            \item Distribute negations inward using equivalences.
            \begin{enumerate}[label=(\roman*)]
                \item `$\lnot\lnot{}{p}$' converts into `$p$'.
                \item `$\lnot(p\;\lor\;q)$' converts into `$\lnot{p}\;\land\;\lnot{q}$'.
                \item `$\lnot(p\;\land\;q)$' converts into `$\lnot{p}\;\lor\;\lnot{q}$'.
                \item `$\lnot(p \to q)$' converts into `$(p\;\land\;\lnot{q})$'.
                \item `$\lnot(p \leftrightarrow q)$' converts into `$(p\;\land\;\lnot{q})\;\lor\;(\lnot{p}\;\land\;q)$'.
            \end{enumerate}
            \item Distribute `$\lor$' over `$\land$'.
        \end{enumerate}
    }%
}

We will use the previous connective recognizers from \nestedlang{LOGIC}, only needing to modify the reducers. We do make one modification in that atoms are now represented as symbols rather than a tagged list.\footnote{The former representation was \ttt{(atom $a$)} where \ttt{$a$} was a symbol. Our current representation omits the tag and list.} The root reducer serves as a standard dispatch function.

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define value-of-cnf
 ((*;$\lambda$;*) (wff)
  (cond
   [(atom? wff) wff]
   [(negation? wff) (value-of-negation wff)]
   [(conjunction? wff) (value-of-conjunction wff)]
   [(disjunction? wff) (value-of-disjunction wff)]
   [(implication? wff) (value-of-implication wff)]
   [(biconditional? wff) (value-of-biconditional wff)]
   [else #f])))
\end{lstlisting}
\end{cl}

Let us start by writing \ttt{value-of-conjunction}, which converts both operands of the conjunction, recursively, to CNF.

\begin{cl}[]{}
\begin{lstlisting}[language=MySOutput]
((*;\textbf{\textcolor{blue}{define}};*) value-of-conjunction
 ((*;$\lambda$;*) (wff)
  ((*;\textcolor{blue}{\textbf{let}};*) ([lhs (value-of-cnf (second wff))]
        [rhs (value-of-cnf (third wff))])
   (*;\qq;*)(and ,lhs ,rhs))))
\end{lstlisting}
\end{cl}

Up next we write \ttt{value-of-implication} and \ttt{value-of-biconditional}, which convert the schemata using the equivalence rules as previously specified. These newly-constructed schemata are then passed to the CNF conversion function.

\begin{cl}[]{}
\begin{lstlisting}[language=MySOutput]
((*;\textbf{\textcolor{blue}{define}};*) value-of-implication
 ((*;$\lambda$;*) (wff)
  ((*;\textcolor{blue}{\textbf{let}};*) ([lhs (second exp)]
        [rhs (third exp)])
   (value-of-cnf (*;\qq;*)(or (not ,lhs) ,rhs)))))
\end{lstlisting}
\end{cl}

\begin{cl}[]{}
\begin{lstlisting}[language=MySOutput]
((*;\textcolor{blue}{\textbf{define}};*) value-of-biconditional
 ((*;$\lambda$;*) (wff)
  ((*;\textcolor{blue}{\textbf{let}};*) ([lhs (second wff)] 
        [rhs (third wff)])
   (value-of-cnf (*;\qq;*)(or (and ,lhs ,rhs)
                      (and (not ,lhs) (not ,rhs))))))))
\end{lstlisting}
\end{cl}

Now we must handle negation via \ttt{value-of-negation}. There are two types of negated schemata: simply and complexly. Simply-negated schemata are of the form $\lnot\lnot{}S$ for any schema $S$, in which we remove the negations. Complexly-negated schemata are any negated binary connective. In either case, every negated schema has a \textit{second} representing the negated schema that we denote as \textit{val}. If \textit{val} is an atom, we do nothing except return the original expression, since an atom cannot be converted further. If \textit{val} is a negated schema, we recursively convert the sub-schema of \textit{val}, thereby removing the double negation. If \textit{val} is either a conditional or biconditional, we recursively convert the equivalent translation.\footnote{If we pre-processed the input schema into \textit{negated normal form}, or NNF, we would not need these clauses. We present this as an exercise.}

\begin{cl}[]{}
\begin{lstlisting}[language=MySOutput]
((*;\textbf{\textcolor{blue}{define}};*) value-of-negation
 ((*;$\lambda$;*) (wff)
  ((*;\textbf{\textcolor{blue}{let}};*) ([val (second wff)])
   ((*;\textbf{\textcolor{blue}{cond}};*)
    [(atom? val) wff]
    [(negation? val) 
     (value-of-cnf (second val))]
    [(implication? val) 
     (value-of-cnf (*;\qq;*)(and ,(second val) (not ,(third val))))]
    [(biconditional? val) 
     (value-of-cnf (*;\qq;*)(or (and ,(second val) (not ,(third val)))
                        (and (not ,(second val)) ,(third val))))]
    [(*;\ghd;*)]))))
\end{lstlisting}
\end{cl}

We now consider negated conjunctions and disjunctions, which prepend a negation in front of both operands of the connectives. Since this is a repeated process where the only difference lies in the connective, we will write a function \ttt{distribute-negation}, which affixes a negation connective onto the operands. Using this, we create a connective that is the dual of the one that is negated.

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define distribute-negation
  ((*;$\lambda$;*) (exp)
    (map ((*;$\lambda$;*) (wff) (list 'not wff)) exp)))
\end{lstlisting}
\end{cl}

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define value-of-negation
 ((*;$\lambda$;*) (wff)
  (let ([val (second wff)])
   (cond
    [(*;\ghd;*)]
    [(disjunction? val) 
     (value-of-cnf (cons 'and (distribute-negation (rest val))))]
    [(conjunction? val) 
     (value-of-cnf (cons 'or (distribute-negation (rest val))))]))))
\end{lstlisting}
\end{cl}

Last but certainly not least we come to \ttt{value-of-disjunction}. We know that we need to distribute logical disjunction over logical conjunction, but we only do this in the event where at least one operand is a conjunction. Let us write \ttt{distribute-disjunction}: it receives two expressions, which represent the operands of a disjunction, and recursively performs a distribution. If neither operand is a conjunction, then we return the schemata as operands of a disjunction (effectively reconstructing the original schema). Without loss of generality, we consider the case where the left-hand schema is a conjunction. So, we need to distribute the right-hand schema over the left-hand. For example, such a schema may be `$(p\;\land\;q)\;\lor\;r$'. To correctly distribute the connective, we take the right-hand schema and recursively distribute a disjunction with `$p$' as the left-hand schema and `$r$' as the right-hand, forming `$p\;\lor\;r$'. We then distribute over the other operand, resulting in `$q\;\lor\;r$'. We then collapse these schemata into a conjunction, i.e., `$(p\;\lor\;r)\;\land\;(q\;\lor\;r)$', which is in CNF.

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
;; distribute-disjunction : Schema Schema -> Schema
;; Distributes logical disjunction over logical conjunction.
(define distribute-disjunction
  ((*;$\lambda$;*) (lhs rhs)
    (cond
      [(conjunction? lhs)
       (list 'and
        (distribute-disjunction (second lhs) rhs)
        (distribute-disjunction (third lhs) rhs))]
      [(conjunction? rhs)
       (list 'and
        (distribute-disjunction lhs (second rhs))
        (distribute-disjunction lhs (third rhs)))]
      [else (or-wff lhs rhs)])))
\end{lstlisting}
\end{cl}

We realize this explanation is a bit hard to follow, so we supplement it with two examples.

\example{Distribute $\lor$ over $\land$ in `$(p\;\land\;\lnot{s})\;\lor\;(\lnot{q}\;\land\;\lnot{r})$'.}
\begin{align*}
    &= `[(p\;\land\;\lnot{s})\;\lor\;\lnot{q}]\;\land\;[(p\;\land\;\lnot{s})\;\lor\;\lnot{r}]\text{'}\\
    &= `[(p\;\land\;\lnot{q})\;\land\;(\lnot{s}\;\lor\;\lnot{q})]\;\land\;[(p\;\lor\;\lnot{r})\;\land\;(\lnot{s}\;\lor\;\lnot{r})]\text{'}\\
\end{align*}
\example{Distribute $\lor$ over $\land$ in `$((q\;\land\;r)\;\land\;s)\;\lor\;(\lnot{r}\;\land\;\lnot{s})$'.}
\begin{align*}
    &= `[(\lnot{r}\;\land\;\lnot{s})\;\lor\;s]\;\land\;[(\lnot{r}\;\land\;\lnot{s})\;\lor\;(q\;\land\;r)]\text{'}\\
    &= `[(s\;\lor\;\lnot{r})\;\land\;(s\;\lor\;\lnot{s})]\;\land\;\{[(\lnot{r}\;\land\;\lnot{s})\;\lor\;q]\;\land\;[(\lnot{r}\;\land\;\lnot{s})\;\lor\;r)]\}\text{'}\\
    &= `[(s\;\lor\;\lnot{r})\;\land\;(s\;\lor\;\lnot{s})]\;\land\;\{[(q\;\lor\;\lnot{r})\;\land\;(q\;\lor\;\lnot{s})]\;\land\;[(r\;\lor\;\lnot{r})\;\land\;(r\;\lor\;\lnot{s})]\}\text{'}
\end{align*}
Because disjunction and conjunction are both commutative operations, the order in which we check the operands of a logical disjunction is irrelevant. Therefore there are multiple logically correct and equivalent answers to every CNF; the order we choose is purely coincidental, although applying heuristics to this decision could lower the size of the output (CNF) schema. We present some of these condensing operations as exercises.

We can finally put the pieces together and implement \ttt{value-of-disjunction}, which receives a schema and recursively converts its operands into CNF as arguments to the disjunction distribution function.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-disjunction
 ((*;$\lambda$;*) (wff)
  (let ([lhs (second exp)]
        [rhs (third exp)])
   (distribute-disjunction
    (value-of-cnf lhs)
    (value-of-cnf rhs)))))
\end{lstlisting}\end{cl}

Let us test few schemata to see the results. We will use the examples that we converted, including schemata that use conditionals and biconditionals.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (value-of-cnf 
   '(or p (and q r)))
   
(*;\textbf{>};*) (value-of-cnf 
   '(or (and p (not s)) 
        (and (not q) 
             (not r))))
        
(*;\textbf{>};*) (value-of-cnf 
   '(imp p (and p q)))
   
(*;\textbf{>};*) (value-of-cnf 
   '(imp (or (not p) (not q)) 
         (not (not q))))
         
(*;\textbf{>};*) (value-of-cnf 
   '(iff (or p q) r))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MySOutput]
(and (or p q) (or p r))


(and (and (or p (not q))
          (or p (not r)))
     (and (or (not s) (not q))
          (or (not s) (not r))))
          
(and (or (not p) p) (or (not p) q))


(and (or p q) (or q q))



(and (and (and (or (or p q) (not p))
               (or (or p q) (not q)))
          (or (or p q) (not r)))
     (and (and (or r (not p))
               (or r (not q)))
          (or r (not r))))
\end{lstlisting}
\end{cloast}

\noindent Converting the output into a readable format shows they are, indeed, in CNF.\footnote{To condense the representation, we will assume the logical conjunction and disjunction connectives are $n$-ary rather than binary. Such an assumption provably preserves the semantic behavior.}
\begin{align*}
    &`(p\;\lor\;q)\;\land\;(p\;\lor\;r)\text{'}\\
    &`(p \;\lor\;\lnot{q}) \;\land\;(p \;\lor\;\lnot{r}) \;\land\;(\lnot{s} \;\lor\;\lnot{q}) \;\land\;(\lnot{s} \;\lor\;\lnot{r})\text{'}\\
    &`(\lnot{p}\;\lor\;p)\;\land\;(\lnot{p}\;\lor\;q)\text{'}\\
    &`(p\;\lor\;q)\;\land\;(q\;\lor\;q)\text{'}\\
    &`(p\;\lor\;q \;\lor\;\lnot{p}) \;\land\;(p \;\lor\;q \;\lor\;\lnot{q}) \;\land\;(p \;\lor\;q \;\lor\;\lnot{r}) \;\land\;(r \;\lor\;\lnot{p}) \;\land\;(r \;\lor\;\lnot{q}) \;\land\;(r \;\lor\;\lnot{r})\text{'}\\
\end{align*}
\exercise{3}{chapter-functional}{Implement a \ttt{pp-cnf} function that receives a schema in prefix notation and converts it to infix. As an example, the schema \ttt{\q{}(and (or q r) (imp (not s) (not r)))} might be ``pretty printed'' as \ttt{((q + r) \& (\bt{s} -> \bt{r})).}}

\exercise{3}{chapter-functional}{As we see, converting a schema into CNF can blow up the output schema due to redundant and tautological clauses. Add an optimization to the interpreter that removes redundant clauses, i.e., `$p \leftrightarrow p$', `$p \to p$', `$p \;\lor\;p$', and `$p \;\land\;p$' all reduce to `$p$'. Then, add a pass that removes tautological clauses, e.g., `$p \;\lor\;\lnot{p}$', or `$(q \;\lor\;\lnot{r}) \;\lor\;\lnot(q \;\lor\;\lnot{r})$'. }

\exercise{4}{chapter-functional}{Using variadic-argument logical conjunction and disjunction removes redundant connectives in the final CNF schema. Implement this behavior into the interpreter. Such a modification requires altering the corresponding recognizers and distribution functions. This is tricky to get right, which is why we label it as a four star problem.}

\exercise{4}{chapter-functional}{First-order logic adds variables, constants, predicates, and quantifiers to zeroth-order logic, whilst removing atoms. Design a nested interpreter to process first-order logic schemata. The root reducer function should return whether the schema is well-formed. A first-order logic schema is well-formed if it conforms to the inductive definition from Chapter~\ref{chapter-maths}.}

\exercise{5}{chapter-functional}{Using the previous exercise as a basis, write an algorithm that rewrites a first-order logic schema in \textit{prenex normal form}\index{prenex normal form} (PNF).\footnote{Why do we care about PNF schemata? Similar to CNF schemata, it serves as a normal form for first-order logic automatic theorem proving software.} A first-order logic is in PNF if it is of the form $Q_{1}V_{1}Q_{2}V_{2}\ldots{}Q_{n}V_{n}M$, where $Q_{1}\ldots{}Q_{n}$ are quantifiers, $V_{1}\ldots{}V_{n}$ are variables, and $M$ is a quantifier-free schema called the \textit{matrix}. Schemata in PNF obey similar rules to those in CNF schemata, namely that there are no conditionals or biconditionals, and negations are pushed inwards using equivalence rules as listed in Figure~\ref{fig:demequivalencerules}. Quantifiers are extracted using equivalence rules as listed in Figure~\ref{fig:quantifierequivalencerules}.\footnote{The variable being quantified over within $\forall{x}\psi$ must not be free in $\phi$ so as to avoid accidental variable capture.} Additionally, PNF schemata variables are rewritten so no shadowing occurs. For example, the $x$ bound by `$\exists{x}$' shadows the x bound by `$\forall{x}$' in the schema `$\forall{}x(P(x) \to \exists{}xQ(x,\;a))$'. We rewrite this using a new variable `$\forall{}x(P(x) \to \exists{}yQ(y,\;a))$'. The PNF schema is `$\forall{}x(\exists{y}(\lnot{}P(x)\;\lor\;Q(y,\;a)))$'. Hint: you will need to keep track of which variables are used where (and when) in the schema. Solving this problem in steps, as we did for the CNF nested interpreter, is a good approach. Those steps include removing conditionals and biconditionals, pushing negations inward, renaming shadowed quantifiers and variables, then pulling quantifiers outward.}

% \begin{figure}[ht!]
% \begin{center}
% \begin{align*}
%     \lnot\forall{x}P(x) &\leftrightarrow \exists{x}\lnot{P(x)}\\
%     \lnot\exists{x}P(x) &\leftrightarrow \forall{x}\lnot{P(x)}
% \end{align*}
% \end{center}
% \caption{Negation of Quantifiers}
% \label{fig:demequivalencerules}
% \end{figure}

% \begin{figure}[ht!]
% \begin{minipage}[h]{0.47\linewidth}
% \begin{center}
%     \begin{align*}
%     (\phi\;\lor\;\forall{x}\psi)\;&\leftrightarrow\;\forall{x}(\phi\;\lor\;\psi)\\
%     (\phi\;\lor\;\exists{x}\psi)\;&\leftrightarrow\;\exists{x}(\phi\;\lor\;\psi)\\
%     (\phi\;\land\;\forall{x}\psi)\;&\leftrightarrow\;\forall{x}(\phi\;\land\;\psi)\\
%     (\phi\;\land\;\exists{x}\psi)\;&\leftrightarrow\;\exists{x}(\phi\;\land\;\psi)
% \end{align*}
% \end{center}
% \caption{Quantification ``Extraction'' Rules}
% \label{fig:quantifierequivalencerules}
% \end{figure}


\begin{figure}[ht!]
\centering
\begin{minipage}{.5\textwidth}
\begin{center}
\begin{align*}
    \lnot\forall{x}P(x)\;&\leftrightarrow\;\exists{x}\lnot{P(x)}\\
    \lnot\exists{x}P(x)\;&\leftrightarrow\;\forall{x}\lnot{P(x)}
    &\\
    &\\
    &
\end{align*}
\end{center}
\caption{Negation of Quantifiers}
\label{fig:demequivalencerules}
\end{minipage}%
\begin{minipage}{.5\textwidth}
\begin{center}
    \begin{align*}
    (\phi\;\lor\;\forall{x}\psi)\;&\leftrightarrow\;\forall{x}(\phi\;\lor\;\psi)\\
    (\phi\;\lor\;\exists{x}\psi)\;&\leftrightarrow\;\exists{x}(\phi\;\lor\;\psi)\\
    (\phi\;\land\;\forall{x}\psi)\;&\leftrightarrow\;\forall{x}(\phi\;\land\;\psi)\\
    (\phi\;\land\;\exists{x}\psi)\;&\leftrightarrow\;\exists{x}(\phi\;\land\;\psi)
\end{align*}
\end{center}
\caption{Negation of Quantifiers}
\label{fig:quantifierequivalencerules}
\end{minipage}
\end{figure}

\clearpage
\subsection*{\nestedlang{BOUND}\index{\nestedlang{BOUND}}: Bound Variable Determiner}
In the $\lambda$-calculus, lambda terms contain two pieces: the formal parameter declaration, and a body. Knowing what variables are bound versus those that are free is often useful. In this section, we will write an interpreter to recognize simple lambda calculus expressions whose main purpose is to count the number of bound variables. Recall that, in a lambda calculus expression, a bound variable is one that occurs as a formal parameter and also occurs in the body of said expression. For instance, in \texttt{(lambda (x) ($\ldots$x$\ldots$))}, \texttt{x} is bound. The complexity of the inner expression is irrelevant---as long as the variable occurs, it is bound. Conversely, in \texttt{((lambda (y) x) y)}, \texttt{y} is not bound because it is not in the body of the lambda declaration.

As before, we will write a procedure to parse such an expression. Our interpreter accepts three forms: a symbol, a lambda declaration, and function application. Because their functionality is identical, we will reuse \texttt{lambda?} and \texttt{application?} from the previous interpreters.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define bound-count
 ((*;$\lambda$;*) (exp env)
  (cond
   [(symbol? exp) (*;\textcolor{lightgray}{$\ldots$};*)]
   [(lambda? exp) (*;\textcolor{lightgray}{$\ldots$};*)]
   [(application? exp) (*;\textcolor{lightgray}{$\ldots$};*)]
   [else 'error])))
\end{lstlisting}\end{cl}

Environments will have a different representation than they did in the former interpreter. Namely, an environment is nothing more than a list of symbols that were declared as formal parameters. Each time we encounter a lambda expression, we extract the symbol and add it to this list for later lookup. Along those lines, once we find a symbol, we search the environment for the variable and, if it exists, we return 1 and otherwise 0. As we recurse over the different parts of the lambda expression, we will continue counting variables---particularly, in the case of function application, we add the result of recursively invoking \texttt{bound-count} on the operator and operand. Let us go from the bottom-up and work on the \texttt{application} case first.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define application-bound-count
 ((*;$\lambda$;*) (exp env)
  (let ([rator (first exp)]
        [rand (second exp)])
   (+ (bound-count rator env)
      (bound-count rand env)))))
         
(define bound-count
 ((*;$\lambda$;*) (exp env)
  (cond
   [(symbol? exp) (symbol-bound-count exp env)]
   [(lambda? exp) (lambda-bound-count exp env)]
   [(application? exp) (application-bound-count exp env)]
   [else 'error])))
\end{lstlisting}\end{cl}

Next, we will work with a lambda declaration. We need to extract the formal parameter, store in the environment, and recursively evaluate the body. Because this form of an interpreter is significantly different from the previous, we will not make the environments representation-independent. Moreover, the interpreter does not evaluate any expressions; rather, it returns a single number and nothing more.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define lambda-bound-count
 ((*;$\lambda$;*) (exp env)
  (let ([formal (second exp)]
        [body (third exp)])
   (bound-count body (cons formal env)))))
\end{lstlisting}\end{cl}

Lastly, let us evaluate symbols. If \texttt{exp} is a symbol, we need to search for it in the environment. We can write a helper function, \texttt{member?}, which returns true if a value is in the given list and false otherwise.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define member?
 ((*;$\lambda$;*) (obj ls)
  (cond
   [(null? ls) #f]
   [(eqv? (first ls) obj) #t]
   [else (member? obj (rest ls))])))
\end{lstlisting}\end{cl}

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define symbol-bound-count
 ((*;$\lambda$;*) (exp env)
  (cond
   [(member? exp env) 1]
   [else 0])))
\end{lstlisting}\end{cl}

\noindent Let us throw a few lambda expressions at this to test!

\begin{clonarrow}[]{}\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (bound-count (*;\textquotesingle;*)(lambda (x) x) (*;\textquotesingle;*)())
(*;\textbf{>};*) (bound-count (*;\textquotesingle;*)(lambda (y) x) (*;\textquotesingle;*)())
(*;\textbf{>};*) (bound-count (*;\textquotesingle;*)((((lambda (x)
                    (lambda (y) 
                     (x (lambda (z) (y z)))))
                   (lambda (q) (r s)))
                  (lambda (t) u))
                 (lambda (v)
                  (lambda (w)
                   (w (lambda (x) (x x))))))            
               (*;\textquotesingle;*)())
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
1
0
5
\end{lstlisting}
\end{clonarrow}

\clearpage
\subsection*{\nestedlang{SETS}: Set Operations Interpreter}
In Chapter~\ref{chapter-maths}, we discussed sets as well as their accompanying operations and details on proving properties of sets. In this section, we will write \nestedlang{SETS}\index{\nestedlang{SETS}}: a nested interpreter for computing properties of sets.

Our language will be completely functional; wherein we may define local variables via \texttt{let} bindings. Sets are defined as lists whose \textit{first} is the symbol \texttt{set} and whose \textit{rest} is a list of arbitrary values.  
Let us begin by writing a root reducer: \texttt{value-of}. From there, we will write each recognizer and reducer side-by-side. Namely, each recognizer and reducer correspond to a set operation, variable declaration, or set definition. The only recognizer and reducer pair that we will not write are those for numbers and variables (represented as symbols), which are trivial to handle.\footnote{\nestedlang{SETS} does not account for duplicate values in a set, meaning these reducers may produce incorrect results when a set contains duplicates.}

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of
 ((*;$\lambda$;*) (exp env)
  (cond
   [(number? exp) exp] 
   [(symbol? exp) (apply-env exp env)]
   [(set? exp) (value-of-set exp env)] 
   [(let? exp) (value-of-let exp env)]
   [(member-set? exp) (value-of-member-set exp env)] 
   [(union? exp) (value-of-union exp env)]
   [(intersection? exp) (value-of-intersection exp env)] 
   [(difference? exp) (value-of-difference exp env)]
   [(subset? exp) (value-of-subset exp env)] 
   [(proper-subset? exp) (value-of-proper-subset exp env)]
   [(set-equal? exp) (value-of-set-equal exp env)] 
   [(firstdinality? exp) (value-of-cardinality exp env)]
   [(complement? exp) (value-of-complement? exp env)] 
   [(firsttesian-product? exp) (value-of-cartesian-product exp env)]
   [(power-set? exp) (value-of-power-set? exp env)]
   [else 'error-unknown-set-operation])))
\end{lstlisting}\end{cl}

For simplicity, we will only implement the first six recognizers and reducers and leave the remaining as exercises to the reader.

To start, we need a way of recognizing a set declaration. As we stated, a set is defined as a list with a \textit{first} tag. E.g., \texttt{(set {4 3 2})} is a valid set declaration. Let us write the accompanying recognizer and reducer, neither of which are non-trivial. Reducing a set is as simple as returning the defined set (list).

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define set?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 2)
       (eqv? (first exp) 'set))))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-set
 ((*;$\lambda$;*) (exp env)
  (second exp)))
\end{lstlisting}
\end{clrr}

Let us now write the \texttt{let} recognizer and reducer. All we need to do is, when encountering a \texttt{let}, we evaluate the variable binding and evaluate the expression being bound to the identifier. We then evaluate the body of the \texttt{let} with respect to an extended environment containing a binding from the identifier to its corresponding expression.

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define let?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 3)
       (eqv? (first exp) 'let))))
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-let
 ((*;$\lambda$;*) (exp env)
  (let* ([lobindings (second exp)]
         [binding (first lobindings)] 
         [id (first binding)]
         [S (value-of 
             (second binding) 
             env)] 
         [body (third exp)])
   (value-of body 
             (extend-env id S env)))))
\end{lstlisting}
\end{clrr}

This allows us to write expressions of the following format, e.g., we declare two sets \texttt{A} and \texttt{B} as such. Note that, to keep with the general theme of set initialization, we use braces to denote the elements of a set. 

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (value-of 
   (*;\q;*)(let ([A (set {1 2 3 4 5})])
     (let ([B (set {3 5 7 9})])
      A)))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
(1 2 3 4 5)
\end{lstlisting}
\end{cloast}

Now that we have a notion of constructing sets and variables via local bindings, we can begin to write operations that act on sets. We shall start with the simplest: set membership, i.e., `$\in$'. An element $x \in S$ where $S$ is some set if and only if $x$ is a member of $S$. Fortunately for us, we wrote \ttt{member?} when designing \nestedlang{BOUND}, so we should reuse its definition in \nestedlang{SETS}.

With \ttt{member?} in hand, we can write the membership recognizer and reducer. \nestedlang{SETS} uses infix operators rather than prefix, meaning that we must check the \textit{second} of an expression list for its operator rather than its \textit{first}. Because our interpreter does not support special characters, i.e., `$\in$', we will encode set membership as the symbol \texttt{in}. For instance, we may ask \texttt{\textquotesingle(5 in (set {4 2 5 8}))}, which should, of course, return \texttt{\#t}. The reducer evaluates the argument, i.e., $x$, as well as the set argument, i.e., $S$, then invokes the utility \texttt{member?} function.\footnote{We must affix \ttt{-set} to the recognizer and reducer names so as to not conflict with our earlier (and distinct) definition of \ttt{member?}.}

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define member-set?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 3)
       (eqv? (second exp) 'in))))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-member-set
 ((*;$\lambda$;*) (exp env)
  (let ([x (value-of (first exp) env)]
        [S (value-of (third exp) env)])
   (member? x S))))
\end{lstlisting}
\end{clrr}

Now, let us write a difficult operation: set union, i.e., `$\cup$'. Recall that the union of two sets $A$ and $B$, denoted by $A\;\cup\;B$, is the set of elements that are in either $A$ or $B$. Our recognizer will use a capital \texttt{U} to denote union (which we will omit in our listings due to redundancy). The reducer is a bit more complicated because it should receive an expression and an environment, but compute the union of the two set arguments. Consequently, we define a local recursive procedure \texttt{union} via \texttt{letrec}, and extract then evaluate the set arguments via \texttt{let}. The object that is returned from \texttt{union}, however, is \textit{not} a ``set'' according to our definition, meaning we should wrap it in quasiquotes.

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define value-of-union
 (letrec ([union 
           ((*;$\lambda$;*) (sA sB)
            ((*;\textcolor{lightgray}{$\ldots$};*)))])
  ((*;$\lambda$;*) (exp env)
   (let ([sA (value-of (first exp) env)]
         [sB (value-of (third exp) env)])
    (cons 'set (union sA sB))))))
\end{lstlisting}
\end{cl}

Thinking about \texttt{union} algorithmically, we have three cases to consider, where the first is trivial. If the first set is empty, we return the second.
Now, we need to do something based on the element at the \textit{first} of \texttt{sA} which we will denote as $e$. If $e\;\in\;\texttt{sB}$, then we should \textit{not} add it to the recursively-constructed set because it will be added in the fourth case to consider. So, we just call \texttt{union} with \texttt{(rest sA)} and \texttt{sB}.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-union
 (letrec ([union 
           ((*;$\lambda$;*) (sA sB)
            (cond
             [(*;\textcolor{lightgray}{$\ldots$};*)]
             [(member? (first sA) sB) (union (rest sA) sB)]
             [else (*;\textcolor{lightgray}{$\ldots$};*)]))])
  (*;\textcolor{lightgray}{$\ldots$};*)))
\end{lstlisting}\end{cl}

The last case is, of course, when $e\;\not\in\;\texttt{sB}$. If this is true, then we want to add it to the recursively-constructed set since this is the only time that we will be able to add $e$ as sets do not contain duplicate values. Therefore, we create a \textit{cons} pair whose \textit{first} is $e$ and whose \textit{rest} is the result of recursively applying \texttt{union} on \texttt{(rest sA)} and \texttt{sB}. 

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-union
 (letrec ([union 
           ((*;$\lambda$;*) (sA sB)
            (cond
             [(*;\textcolor{lightgray}{$\ldots$};*)]
             [else (cons (first sA) (union (rest sA) sB))]))])
  (*;\textcolor{lightgray}{$\ldots$};*)))
\end{lstlisting}\end{cl}

Here's the idea: if $e\in$ \texttt{sB}, we skip over $e$. Eventually, \texttt{sA} will be the empty set, meaning we can conjoin the remaining elements in \texttt{sB} onto the end of \texttt{sA}, hence the base case. Let us write a test case.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (value-of 
   (*;\q;*)(let ([A (set {1 2 3 4 5})])
     (let ([B (set {3 5 7 9})])
      (A U B)))
   (empty-env))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
(set (1 2 3 4 5 7 9))
\end{lstlisting}
\end{cloast}

Let us now write the recognizer and reducer for set difference. Recall that the difference between two sets $A$ and $B$, denoted by ``$\setminus$'' consists of all elements that are in $A$ but not in $B$. In many programming languages, though, the backslash is a reserved special character for representing other types of characters, therefore we choose for set difference to use the arithmetic difference dash \texttt{-}. Much like the reducer for set union, \texttt{value-of-difference} has a local recursive definition to compute the intended result after extracting the sets via \texttt{let}.

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define difference?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 3)
       (eqv? (second exp) '-))))
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define value-of-difference
 (letrec ([diff 
           ((*;$\lambda$;*) (sA sB)
            (cond
             [(*;\textcolor{lightgray}{$\ldots$};*)]))])
  ((*;$\lambda$;*) (exp env)
   (let ([A (value-of (first exp) env)]
         [B (value-of (third exp) env)])
    (cons 'set (diff A B))))))
\end{lstlisting}
\end{clrr}

Again, let us consider the algorithm for computing set difference. We have two base cases: when \texttt{sB} is empty and when \texttt{sA} is empty. In the former case, we return \texttt{sA}, whereas for the latter, we return the empty list (because $\varnothing - S = \varnothing$ for any set $S$).
Next, we check to see if the \textit{first} of \texttt{sA} is in \texttt{sB} and, if so, do not add it to the recursively-constructed set. Otherwise, \textit{cons} the \textit{first} of \texttt{sA} onto the result of recursively invoking \texttt{diff} with a trimmed \texttt{sA}. Notice the striking similarity to the definition of \texttt{value-of-union}. In fact, the only differences include the extra base case and call to \texttt{(rest sB)} in the third \texttt{cond} clause.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-difference
 (letrec ([diff 
           ((*;$\lambda$;*) (sA sB)
            (cond
             [(null? sB) sA]
             [(null? sA) '()]
             [(member? (first sA) sB) (diff (rest sA) (rest sB))]
             [else (cons (first sA) (diff (rest sA) sB))]))])
  ((*;$\lambda$;*) (exp env)
   (*;\textcolor{lightgray}{$\ldots$};*))))
\end{lstlisting}\end{cl}

\noindent Let us throw a few tests at this, using different sets for each run.

\begin{clo}[]{}
\begin{lstlisting}[language=MyScheme]
(define s1 '(set {3 4 5 6 7}))
(define s2 '(set {1 2 3 4}))
(define s3 '(set {1 4 7 10}))
(define s4 '(set {2 3 4 5 6}))
(define s5 '(set {1 2 3 4 10 12}))
(define s6 '(set {}))

(*;\textbf{>};*) (value-of
    (*;\textasciigrave;*)((*;\textmd{let};*) ([A ,s1]) ((*;\textmd{let};*) ([B ,s2]) (A - B))) 
    (empty-env))
(*;\textbf{>};*) (value-of 
    (*;\textasciigrave;*)((*;\textmd{let};*) ([C ,s3]) ((*;\textmd{let};*) ([D ,s4]) (C - D))) 
    (empty-env))
(*;\textbf{>};*) (value-of 
    (*;\textasciigrave;*)((*;\textmd{let};*) ([E ,s5]) ((*;\textmd{let};*) ([F ,s6]) (E - F))) 
    (empty-env))
(*;\textbf{>};*) (value-of 
    (*;\textasciigrave;*)((*;\textmd{let};*) ([G ,s2]) ((*;\textmd{let};*) ([H ,s5]) (G - H))) 
     (empty-env))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]







(set {5 6 7})


(set {1 7 10})


(set {1 2 3 4 10 12})


(set {})
\end{lstlisting}
\end{clo}

\exercise{1}{chapter-functional}{The cardinality function, which we will denote in code as `\texttt{size}', returns the number of elements in a set. Write the recognizer/reducer pair \texttt{cardinality?}/\texttt{value-of-cardinality}.}

\exercise{1}{chapter-functional}{The intersection function, which we will denote in code as `\texttt{\^}', returns a set of elements that are in both $A$ and $B$. For instance, \texttt{(set \{1 2 3 4\}) \^{} (set \{2 3 5 7\})} resolves to \texttt{(set \{2 3\})}. Write the recognizer/reducer pair for computing set intersections, i.e., \texttt{intersection?}/\texttt{value-of-intersection}.}

\exercise{1}{chapter-functional}{The proper subset function, which we will denote in code as `\texttt{<}', returns \texttt{\#t} if all elements of a set $A$ are in a set $B$ but $A$ is \textit{not} equal to $B$. For instance, \texttt{(set \{1 2 3 4\}) < (set \{1 2 3 4 5\})} resolves to \texttt{\#t}, but \texttt{(set \{1 2 3\}) < (set \{1 2 3\})} resolves to \texttt{\#f}. Write the \texttt{proper-subset?}/\texttt{value-of-proper-subset} recognizer and reducer pair.}

\exercise{1}{chapter-functional}{The subset function, which we will denote in code as `\texttt{=<}', returns \texttt{\#t} if all elements of a set $A$ are in a set $B$ \textbf{or} if $A$ is equal to $B$. For instance, \texttt{(set \{1 2 3 4\}) =< (set \{1 2 3 4 5\})} resolves to \texttt{\#t} and \texttt{(set \{1 2 3\}) =< (set \{1 2 3\})} also resolves to \texttt{\#t}. Write the recognizer/reducer pair \texttt{subset?}/\texttt{value-of-subset}.}

\exercise{2}{chapter-functional}{The set equality function, which we will denote in code as `\texttt{=}', returns \texttt{\#t} if two sets $A$ and $B$ share the same elements and \texttt{\#f} otherwise. Write the recognizer/reducer pair \texttt{set-equal?}/\texttt{value-of-set-equal}. Hint: two sets are equal if they are subsets of each other.}

\exercise{2}{chapter-functional}{The complement function, which we will denote in code as `\texttt{not}', returns the set of all elements that are in a \textit{universe set} $U$ and are not in a set $A$. Suppose that `\texttt{not}' is a binary operator where the set we want to compute the complement of is the right-hand argument and the universe set is the left-hand argument. For instance, \texttt{(set \{1 2 3 4 5 6 7 8 9 10\}) not (set \{2 3 4 5\})} returns \texttt{(set \{1 6 7 8 9 10\})}. Write the recognizer/reducer pair \texttt{complement?}/\texttt{value-of-complement}.}

\exercise{3}{chapter-functional}{The cartesian product, which we will denote in code as `\texttt{X}', is for our purposes a binary operator that computes a set of pairs such that for two sets $A$ of $n$ elements and $B$ of $m$ elements, \ttt{A X B} resolves to the set with $n\cdot{m}$ resolves to the set:
\[
    \texttt{\{(a\textsubscript{1}, b\textsubscript{1}), (a\textsubscript{2}, b\textsubscript{2}), \ldots, (a\textsubscript{n}, b\textsubscript{1}), \ldots, (a\textsubscript{n}, b\textsubscript{n})\}}
\]

For instance, \texttt{((set \{1 2\}) X (set \{a b c\}))} resolves to \texttt{(set \{(1 a) (1 b) (1 c) (2 a) (2 b) (2 c)\})}. Write the recognizer/reducer pair \texttt{cartesian-product?}/\\\texttt{value-of-cartesian-product}.}

\exercise{4}{chapter-functional}{The power set, which we will denote in code as `\texttt{powerset}', computes a set of all possible subsets of a set $A$. For instance, \texttt{(powerset (set \{1 2 3\})} resolves to
\begin{center}
    \texttt{(set \{(set \{\}) (set \{1\}) (set \{2\}) (set \{3\}) (set \{1 2\}) \\(set \{1 3\}) (set \{2 3\}) (set \{1 2 3\})\})}
\end{center}
Write the recognizer/reducer pair \texttt{power-set?}/\texttt{value-of-power-set}.}

\clearpage
\subsection*{\nestedlang{BST}\index{\nestedlang{BST}}: A Functional Binary Search Tree and Sorting Algorithms}

In Chapter~\ref{chapter-datastructures}, we discussed trees and, in particular, binary search trees. This section is dedicated to writing a binary search tree, for numbers, in our interpreted language. 

A binary search tree, as we recall, consists of a node with at most two children: a left and right child. Binary search trees have the \textit{invariant}\index{invariant}, i.e., a property that is forever true, that all values to the left of a node are less and all values to the right are greater.\footnote{Depending on the purpose, some implementations of binary search trees will mirror this invariant.} Before we begin to work with values inside the tree, let us write the definition for constructing an empty tree.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
; A BinarySearchTree is one of:
; - '()
; - (ListOf Number BinarySearchTree BinarySearchTree)

(define bst-create-empty
 ((*;$\lambda$;*) ()
  '()))

(define bst-create
 ((*;$\lambda$;*) (val l r)
  (list val l r)))
\end{lstlisting}\end{cl}

The data definition and accompanying constructor functions are no trouble at all---we define a binary search tree as a list. Namely, a binary search tree is either empty, i.e., the empty list, or is a list whose \textit{first} is a number, whose \textit{second} is the left-hand child, and whose \textit{third} is the right-hand child.

Determining if a binary search tree is empty is an even easier task---we just check if it is \texttt{null?}, meaning we can define a variable as the \texttt{null?} function as follows.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define bst-empty? null?)
\end{lstlisting}\end{cl}

Up next is adding values to the binary search tree. Inserting values is, effectively, a binary search procedure; if the given tree is null, we create a binary search tree with the given value and empty children.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
;; bst-add : BinarySearchTree Number -> BinarySearchTree
;; Adds a value into the binary search tree.
(define bst-add
 ((*;$\lambda$;*) (t val)
  (cond
   [(bst-empty? t) (bst-create val (bst-create-empty) (bst-create-empty))]
   [(*;\textcolor{lightgray}{$\ldots$};*)]
   [else #f])))
\end{lstlisting}\end{cl}

The other cases are slightly more interesting. If $t$'s value \textit{is} insert, then we just return $t$ because we cannot insert a preexisting value into a binary tree. In the likely event that the number is not part of the tree, we check to see if it is less than the current subtree root and, if so, recurse on the left-hand tree. Otherwise, we recurse on the right-hand side.\footnote{In our implementation, the logic is the same with the exception that our comparison is swapped; if the current subtree root is less than the value, we recurse on the right-hand side and vice versa.} To simplify the implementation, we created (but do not show) three helper functions: \texttt{bst-value}, \texttt{bst-left}, and \texttt{bst-right}, which retrieve the value, left child, and right child of a provided binary search tree respectively.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define bst-add
 ((*;$\lambda$;*) (t val)
  (cond
   [(bst-empty? t) (bst-create val (bst-create-empty) (bst-create-empty))]
   [(= (bst-value t) val) t]
   [(< (bst-value t) val) (bst-create (bst-value t)
                                      (bst-left t)
                                      (bst-add (bst-right t) val))]
   [(> (bst-value t) val) (bst-create (bst-value t)
                                      (bst-add (bst-left t) val)
                                      (bst-right t))]
   [else #f])))
\end{lstlisting}\end{cl}

Now that we can add values into a binary search tree, we should write a function that looks up/determines the existence of values. Its template is very similar to value insertion with the exception that we never create a binary search tree---we instead recurse down either side of the tree depending on the input value. If we find the value, we return true and, if the tree is empty, we return false.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
;; bst-search : BinarySearchTree Value -> Boolean
;; Determines if a number exists in a binary search tree.
(define bst-search
 ((*;$\lambda$;*) (t val)
  (cond
   [(bst-empty? t) #f]
   [(= (bst-value t) val) #t]
   [(< (bst-value t) val) (bst-search (bst-right t) val)]
   [(> (bst-value t) val) (bst-search (bst-left t) val)]
   [else #f])))
\end{lstlisting}\end{cl}

Next, we may want a function that computes the height of a binary search tree. The height $h$ of a tree $t$ is the longest path from the root to a leaf. Because there are two possible heights in a tree due to its left and right children, we take the largest of the two computed values.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
;; bst-height : BinarySearchTree -> Number
;; Returns the height of a binary search tree, which is the maximum length
;; from the root to a leaf node.
(define bst-height
 ((*;$\lambda$;*) (t)
  (cond
   [(bst-empty? t) 0]
   [else (add1 (max (bst-height (bst-left t))
                    (bst-height (bst-right t))))])))
\end{lstlisting}\end{cl}

Suppose we want a function that converts a list of numbers into a binary search tree. This seems like it would be easy, and indeed the approach is not complicated, but we will discuss a few key ideas about binary search trees alongside the implementation.
An arbitrary list of numbers may or may not be sorted. Values in a binary search tree are inherently sorted. What this means is, we may write a function \texttt{list->bst} that receives a list $l$ and recursively constructs a binary search tree from each value in the tree. We consider two cases: when the list is empty and when it is non-empty. The empty case is trivial---an empty list corresponds directly to an empty binary search tree. Otherwise, we create a binary search tree whose value is the \textit{first} of $l$.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define list->bst
 ((*;$\lambda$;*) (lon)
  (cond
   [(null? lon) (bst-create-empty)]
   [else
    (let ([val (first lon)]
          [rest (rest lon)])
     (make-bst val (*;\textcolor{lightgray}{$\ldots$};*) (*;\textcolor{lightgray}{$\ldots$};*)))])))
\end{lstlisting}\end{cl}

From here, we must add the two children to our new binary search tree. We know by the binary search tree invariant that each value in a node's left subtree is less than that node's value. Correspondingly, all values in the right subtree are greater than that node's value. So, we can filter these values out via \texttt{filter} and $\lambda$ expressions.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define list->bst
 ((*;$\lambda$;*) (lon)
  (cond
   [(null? lon) (bst-create-empty)]
   [else 
    (let ([val (first lon)]
          [rest (rest lon)])
     (bst-create val
                 (list->bst (filter ((*;$\lambda$;*) (x) (< x val)) rest))
                 (list->bst (filter ((*;$\lambda$;*) (x) (> x val)) rest))))])))
\end{lstlisting}\end{cl}

While this is a convenient function to write, it suffers from a performance issue. Binary search trees are used to search for values quickly. With our implementation of \texttt{list->bst}, though, we end up creating a binary search tree that mirrors a linked list \textit{if} the values in the list are sorted. Linked lists require linear time\index{linear time} to search, whereas a binary search tree should, optimally, require only \textit{logarithmic time}\index{logarithmic time}. How can we resolve this predicament? 
Such a problem occurs when the input list is sorted or is close to being sorted (in either ascending or descending order). So, why not guarantee that the list is sorted, then create the binary tree from that list of values? The only difference with our approach would be to insert values from the \textit{middle} of the list and create the respective left and right subtrees.

To start, we need a function that sorts a list of numbers. There are a dozen-plus ways to sort a list of objects. Some algorithms are much faster, others require extra space, and some are performant under certain circumstances. We will implement the \textit{insertion sort}\index{insertion sort}: a sorting algorithm that works as follows:

\begin{algorithm}[H]
\begin{algorithmic}
\Procedure{Insert}{$e$, $ls$}
  \If {$ls$ is empty}
    \State \Return \textit{cons}($e$, empty)
  \ElsIf {$e$ is less than \textit{first}($ls$)}
    \State \Return \textit{cons}($e$, $ls$)
  \Else
    \State \Return \textit{cons}(\textit{first}($ls$), \textsc{Insert}($e$, \textit{rest}($ls$)))
  \EndIf
\EndProcedure
\\

\Procedure{ISort}{$ls$}
    \If {$ls$ is empty}
      \State \Return empty
    \Else
        \State \Return \textit{foldr}(\textsc{insert}, empty, $ls$)
    \EndIf
\EndProcedure
\end{algorithmic}
\caption{Pseudocode for Insertion Sort Algorithm}
\label{alg:pseudocodeinsertion}
\end{algorithm}

We fold the \textsc{insert} function on the given input list.\footnote{Note that we could write this without the higher-order \textit{foldr} function using natural recursion.} \textsc{insert} receives an element $e$ and a list $ls$ and returns a new list where $e$ is ``properly inserted'' into $ls$. Importantly, the $ls$ passed to \textsc{insert} is sorted. Implementing this is straightforward from the pseudocode, so we will use it without reiterating its implementation verbatim. We will now write \texttt{list->bst-better} which sorts the input list of numbers and constructs a \textit{balanced} binary search tree.\footnote{We sort using \texttt{i-sort} whose definition is omitted.} This is achieved by retrieving the middle element of the list and recursively constructing left and right subtrees.\footnote{The ``middle element'' of a list is found by computing left and right indices of the sub list---each subtree acts only on a given sub list. In the end, we use \texttt{list-ref}, which itself is a linear time function, but this loss in performance is alleviated after the binary search tree is constructed.}

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
;; list->bst-helper : [ListOf Number] -> BinarySearchTree
;; Constructs a "balanced" binary search tree from a list of numbers.
(define list->bst-better
 (letrec ([list->bst-helper
           ((*;$\lambda$;*) (lon low high)
            (cond
             [(>= low high) (bst-create-empty)]
             [else (let* ([mid (quotient (+ low high) 2)]
                          [mide (list-ref mid lon)])
                    (bst-create mide
                                (list->bst-helper lon low mid)
                                (list->bst-helper lon (add1 mid) high)))]))])
  ((*;$\lambda$;*) (lon)
   (let* ([slon (i-sort lon)]
          [len (length slon)])
    (list->bst-helper slon 0 len)))))
\end{lstlisting}\end{cl}

\noindent Testing a few binary search trees with our new approach demonstrates immediate improvements.

% Tree 1
\begin{cloast}[]{}
\begin{lstlisting}[language=MyScheme]
(define ls1 '(1 2 3 4 5))

(*;\textbf{>};*) (list->bst ls1)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower\begin{lstlisting}[language=MyVOutput]


(1 () 
   (2 () 
      (3 () 
         (4 () 
            (5 () ())))))
\end{lstlisting}
\end{cloast}

%% Tree 2
\begin{cloast}[]{}
\begin{lstlisting}[language=MyScheme]
(define ls2 '(6 10 5 8 3 2 1 9 4 7))

(*;\textbf{>};*) (list->bst ls2)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyVOutput]


(6 (5 (3 (2 (1 () ()) 
               ()) 
            (4 () ())) 
         ()) 
   (10 (8 (7 () ()) 
          (9 () ())) 
       ()))
\end{lstlisting}
\end{cloast}

% Tree 3
\begin{cloast}[]{}
\begin{lstlisting}[language=MyScheme]
(define ls1 '(1 2 3 4 5 6 7 8 9 10))

(*;\textbf{>};*) (list->bst-better ls1)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyVOutput]


(6 (3 (2 (1 () ()) ()) 
   (5 (4 () ()) 
      ())) 
   (9 (8 (7 () ()) 
         ()) 
      (10 () ())))
\end{lstlisting}
\end{cloast}

% Tree 4
\begin{cloast}[]{}
\begin{lstlisting}[language=MyScheme]
(define ls2 '(6 10 5 8 3 2 1 9 4 7))

(*;\textbf{>};*) (list->bst-better ls2)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyVOutput]


(6 (3 (2 (1 () ()) ()) 
   (5 (4 () ()) 
      ())) 
   (9 (8 (7 () ()) 
         ()) 
      (10 () ())))
\end{lstlisting}
\end{cloast}

Imagine calling the former \texttt{list->bst} function on a list with, say, one million elements. If the list was sorted, there would be no performance gains over just linearly searching through the original list! Furthermore, notice that \texttt{list->bst-better} returns the same binary search tree for both \texttt{ls1} and \texttt{ls2} which is expected behavior. 

The insertion sort algorithm we chose is simple to implement. Along these lines, we will demonstrate another easy-to-understand sorting algorithm: the \textit{selection sort}\index{selection sort}. Selection sort first extracts, and removes, the minimum element $e$ from a list $l$. This means that $l-e=l'$ and $|l'|=|l|-1$, so the list always shrinks. From this, it constructs a new list where $e$ is the \textit{first}, and we recursively selection sort $l'$ as the \textit{rest}. So, let us write two helper functions: \texttt{list-min} and \texttt{list-remove}.\footnote{We will omit the definition of \texttt{min} as it is trivial to write.}\textsuperscript{,}\footnote{Note the use of the higher-order function \texttt{foldr}. Writing \texttt{list-min} without \texttt{foldr} is certainly possible, but requires either a helper function or an extra parameter. Can you explain why?}

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
;; list-min : [NEListOf Number] -> Number
;; Finds the minimum number in a list of numbers.
(define list-min
 ((*;$\lambda$;*) (ls)
  (foldr min (first ls) ls)))

;; list-remove : [NEListOf Number] Number -> [ListOf Number]
;; Removes the first occurrence of some number in a list.
(define list-remove
 ((*;$\lambda$;*) (ls m)
  (cond
   [(null? ls) '()]
   [(eqv? (first ls) m) (rest ls)]
   [else (cons (first ls) (list-remove (rest ls) m))])))
\end{lstlisting}\end{cl}

Now we have everything we need to implement \texttt{s-sort}. Its body uses our auxiliary functions and recursively constructs a sorted list.

\begin{cl}[]{Selection Sort Implementation}\begin{lstlisting}[language=MyScheme]
;; s-sort : [ListOf Number] -> [ListOf Number]
;; Selection sorts a list of numbers.
(define s-sort
 ((*;$\lambda$;*) (ls)
  (cond
   [(null? ls) ls]
   [else 
    (let* ([min-e (list-min ls)]
           [n-ls (list-remove ls min-e)])
     (cons min-e (s-sort n-ls)))])))
\end{lstlisting}\end{cl}

As we have stated, both the insertion and selection sorts make the most sense intuitively but suffer from poor performance as the input list grows in size. A better alternative, in most circumstances, is the \textit{merge sort}\index{merge sort}: a popular divide-and-conquer\index{divide-and-conquer} algorithm. It first subdivides a list into two lists (down the middle) and recursively sorts those. These two lists are then merged (hence the name!) into one sorted list. Consider sorting the following list: \texttt{\textquotesingle(-1 5 -2 6 3 -7 -6 5)}.\footnote{Thanks, Steve Tate, for requiring us to draw this out in the UNC Greensboro algorithm analysis course.}
\begin{figure}[H]
\begin{center}
	\begin{tikzpicture}
	\tikzset{every tree node/.style={align=center, anchor=south}, level distance=1.5cm, sibling distance = 0.07cm}
  \scalebox{.90}{
	\Tree 
	[.{\texttt{\textquotesingle(-1 5 -2 6 3 -7 -6 5)}}
	    %LEFT
		[.{\texttt{\textquotesingle(-1 5 -2 6)} (1$\to$4)}
		    [.{\texttt{\textquotesingle(-1 5)} (1$\to$2)}
		        [.{\texttt{\textquotesingle(-1)} (1)}
		        ]
		        [.{\texttt{\textquotesingle(5)} (2)}
		        ]
		    ]
		    [.{\texttt{\textquotesingle(-2 6)} (3$\to$4)}
		    	[.{\texttt{\textquotesingle(-2)} (3)}
		        ]
		        [.{\texttt{\textquotesingle(6)} (4)}
		        ]
		    ]
		]
		%RIGHT
		[.{\texttt{\textquotesingle(3 -7 -6 5)}  (5$\to$8)}
		    [.{\texttt{\textquotesingle(3 -7)} (5$\to$6)}
		        [.{\texttt{\textquotesingle(3)} (5)}
		        ]
		        [.{\texttt{\textquotesingle(-7)} (6)}
		        ]
		    ]
		    [.{\texttt{\textquotesingle(-6 5)} (7$\to$8)}
		    	[.{\texttt{\textquotesingle(-6)} (7)}
		        ]
		        [.{\texttt{\textquotesingle(5)} (8)}
		        ]
		    ]
		]
	];
 }
	\end{tikzpicture}
	%REVERSED TREE
	\begin{tikzpicture} [grow'=up]
	\tikzset{every tree node/.style={align=center, anchor=south}, level distance=1.5cm, sibling distance = 0.07cm}
 \scalebox{.90}{
	\Tree 
	[.{\texttt{\textquotesingle(-7 -6 -2 -1 3 5 5 6)} (1$\to$8)}
	    %LEFT
		[.{\texttt{\textquotesingle(-2 -1 5 6)} (1$\to$4)}
		    [.{\texttt{\textquotesingle(-1 5)} (1$\to$2)}
		        [.{\texttt{\textquotesingle(-1)} (1)}
		        ]
		        [.{\texttt{\textquotesingle(5)} (2)}
		        ]
		    ]
		    [.{\texttt{\textquotesingle(-2 6)} (3$\to$4)}
		    	[.{\texttt{\textquotesingle(-2)} (3)}
		        ]
		        [.{\texttt{\textquotesingle(6)} (4)}
		        ]
		    ]
		]
		%RIGHT
		[.{\texttt{\textquotesingle(-7 -6 3 5)} (5$\to$8)}
		    [.{\texttt{\textquotesingle(-7 3)} (5$\to$6)}
		        [.{\texttt{\textquotesingle(3)} (5)}
		        ]
		        [.{\texttt{\textquotesingle(-7)} (6)}
		        ]
		    ]
		    [.{\texttt{\textquotesingle(-6 5)} (7$\to$8)}
		    	[.{\texttt{\textquotesingle(-6)} (7)}
		        ]
		        [.{\texttt{\textquotesingle(5)} (8)}
		        ]
		    ]
		]
	];
 }
	\end{tikzpicture}
\end{center}
\caption{Merge Sort Illustration}
\label{fig:mergesortill}
\end{figure}

As the diagram shows, we first divide the input list into sublists recursively, then merge them together. All inputs to the \textit{merge} part of the merge sort are already sorted, so it is a simple linear time operation. Let us start by writing a function that splits a list in half by returning the left half as the \textit{first} of a \textit{cons} pair and the right half as the \textit{rest}. This in and of itself, however, requires two helper functions: \texttt{take} and \texttt{drop}. The former receives a list and an integer $n$ and returns a list with the first $n$ elements of the list. The latter on the other hand receives a list and an integer $n$ and returns a list \textit{without} the first $n$ elements. We will show a few examples of these functions but leave them as exercises to the reader to implement.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNSOutput]
(*;\textbf{>};*) (take '(1 2 3 4 5 6 7 8 9) 5)
(*;\textbf{>};*) (drop '(1 2 3 4 5 6 7 8 9) 5)
(*;\textbf{>};*) (take '(1 2 3 4 5 6 7 8 9) 0)
(*;\textbf{>};*) (drop '(1 2 3 4 5 6 7 8 9) 0)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
(1 2 3 4 5)
(6 7 8 9)
()
(1 2 3 4 5 6 7 8 9)
\end{lstlisting}
\end{cloast}

\noindent Using these two functions, we can now implement \texttt{split}:

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
;; split : {X} [ListOf X] -> (cons [ListOf X] [ListOf X])
;; Returns a cons pair whose fst is the left-half 
;; of the list and whose rst is the right-half.
(define split
 ((*;$\lambda$;*) (ls)
  (let ([len (length ls)]
        [mid (quotient len 2)])
   (cond
    [(<= len 1) (cons '() ls)]
    [else (cons (take ls mid) (drop ls mid))]))))
\end{lstlisting}\end{cl}

Up next is the \texttt{merge} function--it receives two sorted lists of elements and combines their elements in sorted order.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
;; merge : {X} [ListOf X] [ListOf X] -> [ListOf X]
;; Combines two sorted lists.
(define merge
 ((*;$\lambda$;*) (ls1 ls2)
  (cond
   [(null? ls1) ls2]
   [(null? ls2) ls1]
   [(< (first ls1) (first ls2))
    (cons (first ls1) (merge (rest ls1) ls2))]
   [else 
    (cons (rest ls2) (merge ls1 (rest ls2)))])))
\end{lstlisting}\end{cl}

Lastly, we combine these functions to write \texttt{m-sort}. All we do is recursively call \texttt{m-sort} on the left and right split lists and merge their contents.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
;; m-sort : [ListOf Number] -> [ListOf Number]
;; Merge sorts a list of numbers.
(define m-sort
 ((*;$\lambda$;*) (ls)
  (let ([len (length ls)])
   (cond
    [(<= len 1) ls]
    [else (let* ([mid (quotient len 2)]
                 [spair (split ls len mid)]
                 [lhs (first spair)]
                 [rhs (rest spair)])
           (merge (m-sort lhs) (m-sort rhs)))]))))
\end{lstlisting}\end{cl}

Finally, we will discuss the \textit{quicksort}\index{quicksort}: another divide-and-conquer\index{divide-and-conquer} sorting algorithm. Fortunately, this function is the easiest to write since it requires writing only one function. Quicksort returns the empty list if its input is empty. Otherwise, we choose a \textit{pivot} $p$\index{pivot}, i.e., an element of the list. We then subdivide the list into three partitions: $l_1$, $l_2$, and $l_3$. $l_1$ contains all elements that are strictly less than the pivot, $l_2$ contains all elements that are equal to the pivot, and $l_3$ contains all elements that are strictly greater than the pivot. This is easily achievable by using the \texttt{filter} function:\footnote{It must be noted that writing an \textit{optimal} quicksort algorithm is difficult, since the best value of $p$ would be to pick the middle element of the data set (wherein there are roughly one-half of the elements on either side of $p$), which is not easily computable without sorting the list!}

\begin{cl}[]{Quicksort Filtering}\begin{lstlisting}[language=MyScheme]
(define q-sort
 ((*;$\lambda$;*) (ls)
  (cond
   [(null? ls) '()]
   [else (let* ([pivot (first ls)]
                [ltpart (filter ((*;$\lambda$;*) (x) (< x pivot)) ls)]
                [eqpart (filter ((*;$\lambda$;*) (x) (= x pivot)) ls)]
                [gtpart (filter ((*;$\lambda$;*) (x) (> x pivot)) ls)])
          (*;\textcolor{lightgray}{$\ldots$};*))])))
\end{lstlisting}\end{cl}

From here, we need to recursively sort the left and right partitions (note that we do not sort \texttt{eqpart} as that is nonsensical). This is followed up by appending each sublist to the resulting list.

\begin{cl}[]{Quicksort Implementation}\begin{lstlisting}[language=MyScheme]
;; q-sort : [ListOf Number] -> [ListOf Number]
;; Quicksorts a list of numbers.
(define q-sort
 ((*;$\lambda$;*) (ls)
  (cond
   [(null? ls) '()]
   [else
    (let* ([pivot (first ls)]
           [ltpart (filter ((*;$\lambda$;*) (x) (< x pivot)) ls)]
           [eqpart (filter ((*;$\lambda$;*) (x) (= x pivot)) ls)]
           [gtpart (filter ((*;$\lambda$;*) (x) (> x pivot)) ls)])
     (let ([ltl (q-sort ltpart)]
           [gtl (q-sort gtpart)])
      (append ltl (append eqpart gtl))))])))
\end{lstlisting}\end{cl}

Interestingly enough, there exist data structures that automatically balance a binary search tree called \textit{height-balancing trees}, e.g., AVL\index{AVL}, red-black\index{red-black}, and B-trees\index{b-tree}.

% \clearpage
% \subsection*{\nestedlang{RBT}: Persistent Data Structures and Red-Black Trees}

% Our previous implementation of binary search trees was \textit{persistent}\index{persistent}, meaning the intermediate trees are not altered; we construct a new tree with new properties. For example, if we want to insert \texttt{20} into the tree \texttt{d1} defined as \texttt{(10 () (50 (40 () ())) (60 ()) ()))))}, we do not modify the original copy of \texttt{d1}, but instead return a new tree with \texttt{5} inserted into the correct spot. Imperative languages, e.g., C, Java, Python, traditionally do not use persistent data structures instead opting for \textit{ephemeral} data structures. For instance, modifying a C array changes the original array. Linked lists in C are usually ephemeral due to altering links when adding or removing elements. In a language like C, ephemeral data structures help to preserve memory and reduce the number of necessary allocations; it is generally wasteful to have to allocate an entirely new array/list of nodes just to add or remove a value. On the other hand, every data structure that we have worked with so far in \regularlang{EVAL} (which is, admittedly, only one!) is persistent because \texttt{cons} returns a unique \textit{cons} pair each time the function is invoked.

% As stated, we wrote a binary search tree data structure in \nestedlang{BST}. In this section, we will write \nestedlang{RBT}\index{\nestedlang{RBT}}: a nested interpreter for working with red-black trees.

% A \textit{red-black tree}\index{red-black tree} is a type of binary search tree that has several \textit{invariants}, or properties that are always maintained:

% \begin{enumerate}
%     \item Every node $n$ is assigned a color $c$ from the following set: $\{\textsf{Red},\;\textsf{Black}\}$.
%     \item The root $r$ has a color $c=\textsf{Black}$.
%     \item Every node $n$ has a ``black depth'', namely $d$, denoting the number of black nodes from $n$ to the root of the tree $r$.
%     \item For any node $n$ whose color $c=\textsf{Red}$, with direct descendants $n_1$ and $n_2$, neither $n_1$ nor $n_2$ have colors $n_1{_c}=\textsf{Red}$, $n_2{_c}=\textsf{Red}$. This means that red nodes cannot have red children.
%     \item For any node $n$ with direct descendants $n_1$ and $n_2$, $n_1{_d}=n_2{_d}$. This means that black nodes can have either red or black children.
% \end{enumerate}

% A red-black tree is a \textit{height-balanced tree}\index{height-balanced tree}, meaning its left and right subtrees differ by a depth no more than one. Maintaining a balanced tree ensures fast element retrieval times. Recall that a binary search tree, in the worst case, takes the form of a linked list. Consider Figure ~\ref{fig:rlbinarytree}, which shows a right-leaning binary tree alongside its code representation.

% \begin{figure}[H]
% \begin{minipage}{0.5\textwidth}
% \centering
% \begin{verbatim}
% (1 () 
%    (2 () 
%       (3 () 
%          (4 () 
%             (5 () 
%                (6 () ()))))))
% \end{verbatim}
% \end{minipage}
% \begin{minipage}{0.5\textwidth}
% \centering
% \begin{forest}
% for tree={%
%   font=\sffamily,
%   forest node,
%   edge path={
%     \noexpand\path[color=black, \forestoption{edge}]
%       (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
%   },
% }
% [1, arn n
%   [nil, arn n ]
%   [2, arn n
%     [nil, arn n ]
%     [3, arn n 
%       [nil, arn n ]
%       [4, arn n 
%         [nil, arn n ]
%         [5, arn n 
%           [nil, arn n ]
%           [6, arn n 
%             [nil, arn n ]
%             [nil, arn n]
% ]]]]]]
% \end{forest}
% \end{minipage}
% \caption{Right-Leaning Binary Tree}
% \label{fig:rlbinarytree}
% \end{figure}

% Scaling this up to several thousand nodes drastically decreases lookup performance. Compare this with its corresponding red-black tree which automatically readjusts the nodes upon insertion, as demonstrated in Figure ~\ref{fig:rbtreeex1}

% \begin{figure}[H]
% \centering
% \begin{forest}
% for tree={%
%   font=\sffamily,
%   forest node,
%   edge path={
%     \noexpand\path[color=black, \forestoption{edge}]
%       (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
%   },
% }
% [2, arn n
%     [1, arn n
%         [nil, arn n ]
%         [nil, arn n ]
%     ]
%     [4, arn r
%         [3, arn n
%             [nil, arn n ]
%             [nil, arn n ]
%         ]
%         [5, arn n
%             [nil, arn n ]
%             [6, arn r
%                 [nil, arn n ]
%                 [nil, arn n ]
%             ]
%         ]
%     ]
% ]
% \end{forest}
% \caption{Red-Black Tree Example}
% \label{fig:rbtreeex1}
% \end{figure}

% Notice that each red-black tree invariant is preserved. This is applicable to any arbitrary set of numbers and remain true when inserting any other number. Though, how do we actually implement such a structure? First, let us consider some data definitions:

% \begin{cl}[]{}
% \begin{lstlisting}[language=MyScheme]
% ; A Color is one of:
% ; - 'RED
% ; - 'BLACK

% ; A RBTree is one of: 
% ; - 'EMPTY
% ; - (mk-rb-tree Color RBTree Number RBTree)
% \end{lstlisting}
% \end{cl}

% As we see, we define the possible colors as an enumeration of symbols. A red-black tree is a list whose \textit{first} is its color, its \textit{second} is the left child, its \textit{third} is the value, and its \textsc{fourth} is its right child. Let us write a few helper functions to not only construct red-black tree elements, but also accompanying predicates and accessor functions for retrieving parts of a red-black tree. In addition to these functions, we will write a few variables to stand in for symbols that represent components of the red-black tree. The motivation behind this is, once again, representation independence. For instance, we may want to change our data definition to say that a \textsf{Color} uses the lower-cased \texttt{red} and \texttt{black} symbols as opposed to their upper-cased counterparts. Because some of these function\ definitions mirror others, we will omit some definitions and leave them as exercises to the reader to implement.

% \begin{cl}[]{}
% \begin{lstlisting}[language=MyScheme]
% (define Black 'BLACK)
% (define Red 'RED)
% (define Empty 'EMPTY)

% (define rb-color car)
% (define rb-left snd)
% (define rb-value third)
% (define rb-right fourth)

% ;; mk-rb-tree : Color RBTree Number RBTree -> RBTree
% ;; Declares a new RB-tree with empty children and the given color.
% (define mk-rb-tree
%  ((*;$\lambda$;*) (c l x r)
%   (list c l x r)))

% ;; mk-rb-leaf : Number -> RBTree
% ;; Creates a RB-tree leaf node. These are, by default, red.
% (define mk-rb-leaf
%  ((*;$\lambda$;*) (v)
%   (mk-rb-tree Red Empty v Empty)))

% ;; rb-red? : RBTree -> Boolean
% ;; Determines if the RB-tree's color is red. If the tree is empty, return false.
% (define rb-red?
%  ((*;$\lambda$;*) (t)
%   (and (not (rb-empty? t))
%        (eqv? (rb-color t) Red))))
% \end{lstlisting}
% \end{cl}

% Let us now write \texttt{rb-member?}: a function that receives a value and a red-black tree and determines whether that value is inside the red-black tree. Remember that a red-black tree is sorted, meaning we can use identical logic to that of determining membership in a standard binary search tree.

% \begin{cl}[]{}
% \begin{lstlisting}[language=MyScheme]
% ;; rb-member? : Number RBTree -> Boolean
% ;; Determines if the given number is in the red-black tree.
% (define rb-member?
%  ((*;$\lambda$;*) (x t)
%   (cond
%    [(rb-empty? t) #f]
%    [(< (rb-value t) x) (rb-member? x (rb-right t))]
%    [(> (rb-value t) x) (rb-member? x (rb-left t))]
%    [else #t])))
% \end{lstlisting}
% \end{cl}

% Testing this function is possible if we were to manually recreate a red-black tree, which we will now do for demonstrative purposes.

% \begin{clo}[]{}
% \begin{lstlisting}[language=MyScheme]
% (define rb1 
%   (*;\qq;*)(,Black (,Black ,Empty 1 ,Empty) 
%            2 
%            (,Red (,Black ,Empty 3 ,Empty) 
%                  4 
%                  (,Black ,Empty
%                          5
%                          (,Red ,Empty 6 ,Empty)))))

% (*;\textbf{>};*) (rb-member? 3 rb1)
% (*;\textbf{>};*) (rb-member? 11 rb1)
% (*;\textbf{>};*) (rb-member? 6 rb1)
% \end{lstlisting}
% \tcblower
% \begin{lstlisting}[language=MyOutput]









% #t
% #f
% #t
% \end{lstlisting}
% \end{clo}

% Of course, hard-coding values into a red-black tree is cumbersome and prone to errors. What we are after is an insertion procedure much like that for binary search trees. The problem is that such a procedure is much less straightforward than it may first appear. We need to answer a few questions: what does it mean to insert an element into a red-black tree, and how do we maintain its balanced property? The answer is through a series of tree rotations. When we insert a node into a tree, said node starts off red because it is a leaf. Consequently, we may end up in one of four scenarios as described by Okasaki \cite{rbtree}:

% \begin{figure}[H]
% \begin{minipage}[h]{0.47\linewidth}
% \begin{center}
% \begin{forest}
% for tree={%
%   font=\sffamily,
%   forest node,
%   edge path={
%     \noexpand\path[color=black, \forestoption{edge}]
%       (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
%   },
% }
% [10, arn n
%     [4, arn r
%         [1, arn n ]
%         [7, arn r
%             [6, arn n ]
%             [9, arn n]
%         ]
%     ]
%     [20, arn n ]
% ]
% [10, arn n
%     [7, arn r 
%         [4, arn r 
%             [1, arn n]
%             [6, arn n]
%         ]
%         [9, arn n ]
%     ]
%     [20, arn n ]
% ]
% \end{forest}
% \caption{Left-to-Right Rotation}
% \label{lrr}
% \end{center} 
% \end{minipage}
% \hfill
% \vspace{0.2 cm}
% $\Rightarrow$
% \begin{minipage}[h]{0.47\linewidth}
% \begin{center}
% \begin{forest}
% for tree={%
%   font=\sffamily,
%   forest node,
%   edge path={
%     \noexpand\path[color=black, \forestoption{edge}]
%       (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
%   },
% }
% [10, arn n
%     [7, arn r 
%         [4, arn r 
%             [1, arn n]
%             [6, arn n]
%         ]
%         [9, arn n ]
%     ]
%     [20, arn n ]
% ]
% \end{forest}
% \caption{Right-Only Rotation}
% \label{rr}
% \end{center}
% \end{minipage}
% \vfill
% \vspace{0.2 cm}
% \begin{minipage}[h]{0.47\linewidth}
% \begin{center}
% \begin{forest}
% for tree={%
%   font=\sffamily,
%   forest node,
%   edge path={
%     \noexpand\path[color=black, \forestoption{edge}]
%       (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
%   },
% }
% [4, arn n
%     [1, arn n ]
%     [10, arn r 
%         [7, arn r
%             [6, arn n]
%             [9, arn n]
%         ]
%         [20, arn n]
%     ]
% ]
% \end{forest}
% \caption{Right-to-Left Rotation}
% \label{rlr}
% \end{center}
% \end{minipage}
% \hfill
% $\Rightarrow$
% \begin{minipage}[h]{0.47\linewidth}
% \begin{center}
% \begin{forest}
% for tree={%
%   font=\sffamily,
%   forest node,
%   edge path={
%     \noexpand\path[color=black, \forestoption{edge}]
%       (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
%   },
% }
% [4, arn n 
%     [1, arn n ]
%     [7, arn r
%         [6, arn n ]
%         [10, arn r 
%             [9, arn n ]
%             [20, arn n ]
%         ]
%     ]
% ]
% \end{forest}
% \caption{Left-Only Rotation}
% \label{lr}
% \end{center}
% \end{minipage}
% \end{figure}

% The preceding four figures designate red-black tree rotations. Namely, any time we insert a new value into the tree, it results in one of these four configurations. Subsequently, each configuration fails to uphold the ``red-red'' node invariant. To fix this, we simply need to create a tree that resolves the conflict and continues to preserve the other invariants. 

% \begin{figure}[H]
% \begin{center}
% \begin{forest}
% for tree={%
%   font=\sffamily,
%   forest node,
%   edge path={
%     \noexpand\path[color=black, \forestoption{edge}]
%       (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
%   },
% }
% [7, arn r
%     [4, arn n
%         [1, arn n ]
%         [6, arn n ]
%     ]
%     [10, arn n 
%         [9, arn n ]
%         [20, arn n ]
%     ]
% ]
% \end{forest}
% \caption{Resulting Tree From Rotations \ref{rr} and \ref{lr}}
% \label{rbtreeres}
% \end{center}
% \end{figure}

% Recall that the root of the tree must be colored black. So, we recolor the \texttt{7} node to black. We can generalize this approach to use variables or letters, which we will do in our code implementation. 

% We will begin by writing the \texttt{rb-insert} function that, given an element-to-insert $e$ and a red-black tree $t$, inserts $e$ into the proper location of $t$. The tree is balanced according to a later-defined function, and the root is recolored to black. To start, \texttt{rb-insert} is defined as a function that calls a local helper function \texttt{insert-helper}. Such function returns a new red-black tree which is then used to create a new red-black tree whose color is black.

% \begin{cl}[]{}
% \begin{lstlisting}[language=MyScheme]
% ;; rb-insert : Number RBTree -> RBTree
% ;; Inserts the given value into the red-black tree.
% (define rb-insert
%  (letrec ([insert-helper
%            ((*;$\lambda$;*) (e t)
%             (*;\textcolor{lightgray}{$\ldots$};*))])
%   ((*;$\lambda$;*) (e t)
%    (let ([new-t (insert-helper e t)])
%     (mk-rb-tree Black (rb-left new-t) (rb-val new-t) (rb-right new-t))))))
% \end{lstlisting}
% \end{cl}    

% Now, how do we write \texttt{insert-helper}? The base case is trivial: if the red-black tree that we want to insert a node into is empty, then we create a leaf node with the respective value. Otherwise, we recursively insert $e$ into the correct subtree. Additionally, this insertion is followed by a balancing procedure.

% \begin{cl}[]{}
% \begin{lstlisting}[language=MyScheme]
% (define rb-insert 
%  (letrec ([insert-helper
%            ((*;$\lambda$;*) (e t)
%             (cond
%              [(rb-empty? t) (mk-rb-leaf t)]
%              [else
%               (let ([c (rb-color t)] [l (rb-left t)] 
%                     [r (rb-right t)] [v (rb-val t)])
%                (cond
%                 [(< e v) (balance (insert-helper e l) v r)]
%                 [(> e v) (balance l v (insert-helper e r))]
%                 [else t]))]))])
%   (*;\textcolor{lightgray}{$\ldots$};*)))
% \end{lstlisting}
% \end{cl}

% The balance procedure consists of four checks and each correspond to one of the four rotation styles as listed above. Each rotation style has a respective function to coincide that extract node values from the tree to perform the desired rotation as described by Figure \ref{rbtreeres}. Note that we only perform a balance if the current node color is black and it has a ``red-red'' node chain as a child. In the other instance (i.e., when the given node is red), we simply return a new tree with the given properties, as a re-balance is not necessary. To remain consistent with the diagrams laid out by \cite{rbtree}, we will use \texttt{a}, \texttt{b}, \texttt{c}, and \texttt{d} to label children of the to-be rotated subtrees.

% \begin{cl}[]{}
% \begin{lstlisting}[language=MyScheme]
% ;; rb-balance : Color RBTree Number RBTree -> RBTree
% ;; Rebalances a given red-black tree.
% (define rb-balance
%  ((*;$\lambda$;*) (c a y b)
%   (cond
%    [(eqv? Black c)
%     (cond
%      [(and (rb-red? a) (rb-red? (rb-left a))) (rb-llred c a y b)]
%      [(and (rb-red? a) (rb-red? (rb-right a))) (rb-lrred c a y b)]
%      [(and (rb-red? b) (rb-red? (rb-left b))) (rb-rlred c a y b)]
%      [(and (rb-red? b) (rb-red? (rb-right b))) (rb-rrred c a y b)]
%      [else (mk-rb-tree c a y b)])]
%    [else (mk-rb-tree c a y b)])))
% \end{lstlisting}
% \end{cl}

% \begin{cl}[]{Left-Left Rotation}
% \begin{lstlisting}[language=MyScheme]
% ;; rb-llred : Color RBTree Number RBTree -> RBTree
% ;; Rotates a left-left 'red-red' subtree.
% (define rb-llred
%  ((*;$\lambda$;*) (c a y b)
%   (let ([a (rb-left (rb-left a))] [x (rb-val (rb-left a))] 
%         [b (rb-right (rb-left a))] [y (rb-val a)] 
%         [c (rb-right a)] [z y] [d b])
%    (mk-rb-tree Red (mk-rb-tree Black a x b) y (mk-rb-tree Black c z d)))))
% \end{lstlisting}
% \end{cl}

% \begin{cl}[]{Left-Right Rotation}
% \begin{lstlisting}[language=MyScheme]
% ;; rb-lrred : Color RBTree Number RBTree -> RBTree
% ;; Rotates a left-right 'red-red' subtree.
% (define rb-lrred
%  ((*;$\lambda$;*) (c a y b)
%   (let ([a (rb-left a)] [x (rb-val a)] [b (rb-left (rb-right a))]
%         [y (rb-val (rb-right a))] [c (rb-right (rb-right a))] [z y] [d b])
%    (mk-rb-tree Red (mk-rb-tree Black a x b) y (mk-rb-tree Black c z d)))))
% \end{lstlisting}
% \end{cl}

% \begin{cl}[]{Right-Left Rotation}
% \begin{lstlisting}[language=MyScheme]
% ;; rb-rlred : Color RBTree Number RBTree -> RBTree
% ;; Rotates a right-left 'red-red' subtree.
% (define rb-rlred
%  ((*;$\lambda$;*) (c a y b)
%   (let ([x y] [b (rb-left (rb-left b))] [y (rb-val (rb-left b))]
%         [c (rb-right (rb-left b))] [z (rb-val b)] [d (rb-right b)])
%    (mk-rb-tree Red (mk-rb-tree Black a x b) y (mk-rb-tree Black c z d)))))
% \end{lstlisting}
% \end{cl}

% \begin{cl}[]{Right-Right Rotation}
% \begin{lstlisting}[language=MyScheme]
% ;; rb-rrred : Color RBTree Number RBTree -> RBTree
% ;; Rotates a right-right 'red-red' subtree.
% (define rb-rrred
%  ((*;$\lambda$;*) (c a y b)
%   (let ([x y] [b (rb-left b)] [y (rb-val b)] [c (rb-left (rb-right b))]
%         [z (rb-val (rb-right b))] [d (rb-right (rb-right b))])
%    (mk-rb-tree Red (mk-rb-tree Black a x b) y (mk-rb-tree Black c z d)))))
% \end{lstlisting}
% \end{cl}

% \clearpage
\subsection*{\nestedlang{TRIE}\index{\nestedlang{TRIE}}: A Compression Technique}

Data compression\index{data compression} is prominent and ever-present in computer science. Part of this field is to find new and innovative ways to take data, in any arbitrary form, and shrink it as much as possible while retaining some resemblance of the original data. This measure of resemblance is traditionally broken down into two categories, namely lossless\index{lossless compression} versus lossy compression\index{lossy compression}.

In this section, we will focus on a \textit{lossless compression}\footnote{Lossless data compression refers to the fact that the compression technique preserves all data when compressing, and decompressing recovers the original data. Lossy compression, on the other hand, loses some (generally insignificant) data upon compression.} technique for strings by implementing a string compression data structure called a \textit{trie}\index{trie}. This is not to be confused with ``tree'', even though a trie is a kind of tree, also sometimes referred to as a prefix tree. 

Prefix trees, as we stated, store strings and characters. Consider the following repetitive sentence: ``Peter Piper picked a peck of pickled peppers''. A trie decomposes this sentence into prefix nodes\index{prefix node}. Each node corresponds to a letter in the sentence, starting from the root of the trie, where each path from the root to a leaf reconstructs a word in the original sentence. Decomposing the example sentence (treating upper and lower-case letters the same) produces three nodes from the root containing the letters `a', `o', and `p'. The `a' subtrie has no children since the only word that starts with `a' is the word `a' itself. The `o' subtree has one child, namely `f', which has no children since the only word beginning with `o' is ``of''. Finally, we come to the most complex of the collection: words starting with `p'. `p' has two children: `e' and `i'. Each of these have their own subtries containing letters `c', `p', and `t' for `e', and `c', `p' for `i' respectively, which further recursively decompose until no more letters remain.

\begin{figure}[H]
  \begin{center}
  \scalebox{.80}{
  \begin{forest}
  for tree={%
    font=\ttfamily,
    forest node,
    edge path={
      \noexpand\path[color=black, \forestoption{edge}]
        (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
    },
  }
  [\{\}, arn n
      [a, arn n ]
      [o, arn n 
        [f, arn n ]
      ]
      [p, arn n
        [e, arn n
          [c, arn n
            [k, arn n ]
          ]
          [p, arn n
            [p, arn n 
              [e, arn n
                [r, arn n
                  [s, arn n ]
                ]
              ]
            ]
          ]
          [t, arn n
            [e, arn n
              [r, arn n ]
            ]
          ]
        ]
        [i, arn n 
          [c, arn n 
            [k, arn n 
              [e, arn n 
                [d,arn n ]
              ]
              [l, arn n
                [e, arn n
                  [d, arn n ]
                ]
              ]
            ]
          ]
          [p, arn n 
            [e, arn n
              [r, arn n ]
            ]
          ]
        ]
      ]
  ]
  \end{forest}
  }
  \caption{Trie Derivation of ``Peter Piper picked a peck of pickled peppers''.}
  \label{triepeterpiper}
  \end{center}
\end{figure}

In addition to keeping track of which letters form what words, nodes that denote the end of a word have a leaf ``quantity'' node. For example, the sentence ``Hungry Harry alphabetizes his alphabetic soup with alphabet letters'' contains the prefix ``alphabet'' three times, but the word ``alphabet'' itself appears only once (see Figure \ref{hh1}). Similarly, the sentence ``Hungry Harry alphabetizes his alphabetic soup'' contains the prefix ``alphabet'', but does not have alphabet as a word (see Figure \ref{hh2}). 

\begin{figure}[H]
\begin{minipage}[h]{0.47\linewidth}
\begin{center}
\scalebox{.80}{
\begin{forest}
  for tree={%
    font=\sffamily,
    forest node,
    edge path={
      \noexpand\path[color=black, \forestoption{edge}]
        (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
    },
  }
  [\{\}, arn n
    [a, arn n
      [l, arn n
        [p, arn n
          [h, arn n
            [a, arn n
              [b, arn n
                [e, arn n
                  [t, arn n
                    [1, arn c ]
                    [i, arn n
                      [c, arn n 
                        [1, arn c ]
                      ]
                      [z, arn n
                        [e, arn n 
                          [s, arn n 
                            [1, arn c ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
    [h, arn n 
      [a, arn n 
        [r, arn n 
          [r, arn n 
            [y, arn n 
              [1, arn c ]
            ]
          ]
        ]
      ]
      [i, arn n 
        [s, arn n
          [1, arn c ]
        ]
      ]
      [u, arn n 
        [n, arn n 
          [g, arn n 
            [r, arn n 
              [y, arn n 
                [1, arn c ]
              ]
            ]
          ]
        ]
      ]
    ]
    [l, arn n 
      [e, arn n 
        [t, arn n 
          [t, arn n 
            [e, arn n 
              [r, arn n 
                [s, arn n
                  [1, arn c ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
    [s, arn n 
      [o, arn n 
        [u, arn n 
          [p, arn n 
            [1, arn c ]
          ]
        ]
      ]
    ]
    [w, arn n 
      [i, arn n 
        [t, arn n
          [h, arn n 
            [1, arn c ]
          ]
        ]
      ]
    ]
  ]
\end{forest}
}
\caption{Trie Derivation of ``Hungry Harry alphabetizes his alphabetic soup with alphabet letters''}
\label{hh1}
\end{center}
\end{minipage}
\hfill
\begin{minipage}[h]{0.47\linewidth}
\begin{center}
\scalebox{.80}{
\begin{forest}
  for tree={%
    font=\sffamily,
    forest node,
    edge path={
      \noexpand\path[color=black, \forestoption{edge}]
        (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
    },
  }
  [\{\}, arn n
    [a, arn n
      [l, arn n
        [p, arn n
          [h, arn n
            [a, arn n
              [b, arn n
                [e, arn n
                  [t, arn n
                    [i, arn n
                      [c, arn n 
                        [1, arn c ]
                      ]
                      [z, arn n
                        [e, arn n 
                          [s, arn n 
                            [1, arn c ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
    [h, arn n 
      [a, arn n 
        [r, arn n 
          [r, arn n 
            [y, arn n 
              [1, arn c ]
            ]
          ]
        ]
      ]
      [i, arn n
        [s, arn n 
          [1, arn c ]
        ]
      ]
      [u, arn n 
        [n, arn n 
          [g, arn n 
            [r, arn n 
              [y, arn n 
                [1, arn c ]
              ]
            ]
          ]
        ]
      ]
    ]
    [s, arn n 
      [o, arn n 
        [u, arn n 
          [p, arn n 
            [1, arn c ]
          ]
        ]
      ]
    ]
  ]
\end{forest}
}
\caption{Trie Derivation of ``Hungry Harry alphabetizes his alphabetic soup''}
\label{hh2}
\end{center}
\end{minipage}
\end{figure}

With these examples, let us begin to write a trie implementation. First, we need to understand the structure of a trie. We will say that a \texttt{Trie} is a non-recursive data structure, being either a tagged list representing a leaf (containing a count as its \textit{second}) or a list of what we will call \texttt{TrieNode}s. A \texttt{TrieNode}, on the other hand, is a recursive structure; trie nodes are tagged lists with a character as its \textit{second} and a list of trie node children as its \textit{third} (its \textit{first} is the associated tag symbol):

\begin{cl}[]{Data Definition for Trie and TrieNode}
\begin{lstlisting}[language=MyScheme]
; A Trie is one of:
; - (trie-leaf NaturalNumber)
; - [ListOf TrieNode]
;
; A TrieNode is (trie-node Char [ListOf Trie])

(define trie-char snd)
(define trie-children third)
(define leaf-count snd)
\end{lstlisting}
\end{cl}

\begin{cl}[]{Trie Recognizers and Constructors}
\begin{lstlisting}[language=MyScheme]
(define trie?
 ((*;$\lambda$;*) (t)
  (eqv? (first t) 'trie-node)))

(define leaf?
 ((*;$\lambda$;*) (t)
  (eqv? (first t) 'trie-leaf)))

(define (make-trie ch trie-forest)
  (list 'trie-node ch trie-forest))

(define (make-leaf)
  (list 'trie-leaf 1))
\end{lstlisting}
\end{cl}

Let us write a function that takes a word and inserts it into a trie node containing said word and only that word. We recursively traverse the inner string contents, letter by letter, starting with a \texttt{make-trie}, then ending with a \texttt{make-leaf}. Because we want to receive a list of characters as input rather than just a string, we will use the auxiliary \texttt{string->loc} function, which converts a string to a list of characters.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyScheme]
; A Word is a [ListOf Char]

;; word->trienode : Word -> TrieNode
;; Adds a word into an empty trienode.
(define word->trienode
 ((*;$\lambda$;*) (w)
  (cond
   [(empty? w) (make-leaf)]
   [else (make-trie 
          (first w) 
          (list (word->trienode 
                 (rest w))))])))

(*;\textbf{>};*) (word->trienode 
   (string->loc "hungry"))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
(trie-node #\h 
 ((trie-node #\u 
  ((trie-node #\n 
   ((trie-node #\g 
    ((trie-node #\r 
     ((trie-node #\y 
      ((trie-leaf 1)))))))))))))
\end{lstlisting}
\end{cloast}

We now need a function that inserts a word into a preexisting trie. Such a function will use two mutually-recursive locally-defined functions that insert one letter at a time into the trie: \texttt{trienode-insert} and \texttt{trie-insert-helper}. Both functions receive a word, whereas the former receives a trie and the latter receives a list of trie nodes. The latter has two base cases, the first of which handles when the list of trie nodes is empty, meaning we just return a list whose sole element is the word inserted into a trie node. This case occurs when the trie does not have a character as a child node. The second base case happens when we reach the end of the word and the trie is a leaf node, in which we increment its counter by one, meaning the word already exists in the trie. Let us write these two cases and the starter code for both functions. \texttt{make-leaf-add1} receives a leaf node and increments its count by one, returning a new leaf in the process.

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define (make-leaf-add1 lf)
  (list 'trie-leaf (add1 (leaf-count lf))))

;; trie-insert : Word Trie -> Trie
;; Inserts a word into the trie. If the word is already in
;; the trie, its leaf counter is incremented.
(define trie-insert
 (letrec ([trienode-insert
           ((*;$\lambda$;*) (w t)
            (*;\textcolor{lightgray}{$\ldots$};*))]
          [trie-insert-helper
           ((*;$\lambda$;*) (w f)
            (cond
             [(null? f) (list (word->trienode w))]
             [(and (null? w) (leaf? (first f))) 
              (list (make-leaf-add1 (first f)))]))])
    trie-insert-helper))
\end{lstlisting}
\end{cl}

Of course, these two cases do not handle the necessarily interesting piece of the puzzle, that being when we insert a letter in a trie that already contains the given letter. In such instances, there are three possibilities:

\begin{enumerate}
  \item If the word (list) is empty and there is not currently a leaf element at the list of trie nodes, then we need to create one via \texttt{make-leaf} and \texttt{cons}. This occurs when adding words that are prefixes of preexisting words.
  \item If the \textit{first} of the word is equivalent to the \texttt{trie-char} of the \textit{first} of our list of trie nodes, we recurse deeper into the trie by \textit{cons}'ing the result of calling \texttt{trienode-insert} on \texttt{w} with the trie node and the \textit{rest} of the list of trie nodes. 
  \item Otherwise, we recursively create a pair out of the rest of the list of trie nodes.
\end{enumerate}

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define trie-insert
 (letrec ([(*;\textcolor{lightgray}{$\ldots$};*)]
          [trie-insert-helper
           ((*;$\lambda$;*) (w f)
            (cond
             [(*;\textcolor{lightgray}{$\ldots$};*)]
             [(null? w) (cons (make-leaf) f)]
             [(eqv? (first w) (trie-char (first f))) 
              (cons (trienode-insert w (first f)) (rest f))]
             [else 
              (cons (first f) (trie-insert-helper w (rest f)))]))])
  trie-insert-helper))
\end{lstlisting}
\end{cl}

Let us now write \texttt{trienode-insert}, which receives a word and inserts it into a non-empty trie.

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define trie-insert
 (letrec ([trie-node
           ((*;$\lambda$;*) (w t)
            (make-trie (trie-char t) 
                       (trie-insert-helper (rest w) (trie-children t))))]
          [(*;\textcolor{lightgray}{$\ldots$};*)])
  (*;\textcolor{lightgray}{$\ldots$};*)))
\end{lstlisting}
\end{cl}

These two functions are all we need to create a trie. Let us see an example using the sentence from earlier.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyScheme]
(define t1 
 (trie-insert 
  (string->loc "hungry") '()))
(define t2 
 (trie-insert 
  (string->loc "harry") t1))
(define t3 
 (trie-insert 
  (string->loc "alphabetizes") t2))
(define t4 
 (trie-insert 
  (string->loc "his") t3))
(define t5 
 (trie-insert 
  (string->loc "alphabetic") t4))
(define t6 
 (trie-insert 
  (string->loc "soup") t5))
(define t7 
 (trie-insert 
  (string->loc "with") t6))
(define t8 
 (trie-insert 
  (string->loc "alphabet") t7))

(*;\textbf{>};*) t8
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyVOutput]
'((trie-node #\h 
   ((trie-node #\u 
     ((trie-node #\n 
       ((trie-node #\g 
         ((trie-node #\r 
           ((trie-node #\y 
            ((trie-leaf 1))))))))))) 
    (trie-node #\a 
     ((trie-node #\r 
      ((trie-node #\r 
       ((trie-node #\y 
        ((trie-leaf 1))))))))) 
    (trie-node #\i 
     ((trie-node #\s 
      ((trie-leaf 1))))))) 
  (trie-node #\a 
   ((trie-node #\l 
    ((trie-node #\p 
     ((trie-node #\h 
      ((trie-node #\a 
       ((trie-node #\b 
        ((trie-node #\e 
         ((trie-node #\t 
          ((trie-leaf 1) 
           (trie-node #\i 
            ((trie-node #\z 
             ((trie-node #\e 
              ((trie-node #\s 
               ((trie-leaf 1))))))) 
             (trie-node #\c 
              ((trie-leaf 1))))))))))))))))))))) 
  (trie-node #\s 
   ((trie-node #\o 
    ((trie-node #\u 
     ((trie-node #\p ((trie-leaf 1))))))))) 
  (trie-node #\w 
   ((trie-node #\i 
    ((trie-node #\t 
     ((trie-node #\h ((trie-leaf 1))))))))))
\end{lstlisting}
\end{cloast}

Searching for words in a trie is now a trivial and quick task! We pay, up front, the price of creating a trie, but we recuperate most of those costs when querying the inserted words. 

\exercise{2}{chapter-functional}{Write the \texttt{trie-word-count} function that returns the number of times a word appears in a trie. This should not involve any arithmatic operations.}

\exercise{2}{chapter-functional}{Write the \texttt{trie-contains?} predicate which returns true if the given word exists in the given trie and false otherwise. Assuming you wrote \texttt{trie-word-count}, this should be trivial.}

\exercise{3}{chapter-functional}{Write a \texttt{list->trie} function that converts a list of strings into a trie by inserting each string into the trie one after another.}

\exercise{3}{chapter-functional}{Write a \texttt{trie->list} function that converts a trie into a list containing the words from the given trie. Ensure that words are inserted into the list as many times as they exist in the trie.}

\exercise{3}{chapter-functional}{Write a \texttt{trie->remove} function that removes a given word from the given trie. If the word does not exist, then nothing is done. Breaking this problem up into sub-problems may be helpful, e.g., if the trie contains the word and has a count greater than one, if the trie contains the word and has a count equal to one, and if it is non-existent in the trie.}

\clearpage
\subsection*{\nestedlang{DFA}\index{\nestedlang{DFA}}: Deterministic Finite Automaton Recognizer}

In Chapter~\ref{chapter-languages}, we discussed finite automaton and regular expressions\index{regular expression} as methods of symbol recognition in lexical analysis\index{lexical analysis}. In this section, we will write a deterministic finite automaton\index{deterministic finite automaton} recognizer and tester. While this stems away from our use of the term ``nested interpreter'', it is a useful program and allows us to explore how one of these seemingly abstract machines works.

First, recall that a DFA has five components: a set of states $Q$, an alphabet $\Sigma$, a transition function $\delta$, a start state $q$, and a set of final states $F$. We will design a DFA handler, which receives a description of some DFA, and returns a function that allows us to test input strings for acceptance.

Though, how should we build this handler, and namely, how might we want to structure our input data? We will write our DFA as a constructor closure that receives a list of data. Managing the data is the complicated piece due to what all we need to store. A DFA, as we said, contains a set of states $Q$, as well as a transition function $\delta$. Our handler will bring these units together. Namely, a state in our DFA will be a tagged list where the tag, or the \textit{first}, is a state identifier. A state also contains an association list of pairs representing the transition function (these pairs are structured such that the \textit{first} is the input symbol and the \textit{rest} is the destination state). Finally, the third element of the set list is a list of state properties. A state can be either a starting state \ttt{(s)}, a final state \ttt{(f)}, both \ttt{(s f)}, or neither \ttt{()}. We present an example as follows:

\begin{cl}[]{}\begin{lstlisting}[language=MYNLNScheme]
'((q0 ((a . q1) (b . q2)) (s))
  (q1 ((a . q1) (b . q2)) ())
  (q2 ((a . q2) (b . q2)) (f))
\end{lstlisting}\end{cl}

\noindent The above DFA corresponds to the following diagram:

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,semithick]
    \node[state, initial] (q0) {$q_0$};
    \node[state, accepting, below right of=q0] (q2) {$q_2$};
    \node[state, above right of=q2] (q1) {$q_1$};
    
    \draw (q0) edge[bend left] node{$a$} (q1)
          (q0) edge[bend right, above] node{$b$} (q2)
          (q1) edge[loop above, above] node{$a$} (q1)
          (q1) edge[bend left, above] node{$b$} (q2)
          (q2) edge[loop below, below] node{$a, \;b$} (q2);
\end{tikzpicture}
\end{center}
\caption{Simple DFA Example \#1.}
\label{fig:dfanest1}
\end{figure}

Now, let us write the recognizer. As we said, we want this to be a function that receives a list of state data (as described previously), then returns a function that should receive, then test, a string.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define dfa
 ((*;$\lambda$;*) (los)
  (let ([states los])
   ((*;$\lambda$;*) (input)
    (*;\textcolor{lightgray}{$\ldots$};*)))))
\end{lstlisting}\end{cl}

Right now, \texttt{dfa} is a function of one argument: a list-of-states which assigns a field \texttt{states} to be the value of \texttt{los} just for book-keeping purposes. Inside the \texttt{let} block, we want to write a recursive procedure that iterates over each symbol in the input and traverses through the DFA. Let us walk through a simple example.

Suppose we want to determine if the list of symbols \texttt{\textquotesingle(a a a b b)}, representing the string \texttt{"aaabb"}, is in the language defined by the above DFA. 

\begin{enumerate}[label=(\roman*)]
    \item The starting state is $q_0$. The next symbol is \texttt{a}. We transition to $q_1$ using $(\texttt{a}, \;q_1)$.
    \item The next symbol is \texttt{a}. We transition to $q_1$ using $(\texttt{a}, \;q_1)$.
    \item The next symbol is \texttt{a}. We transition to $q_1$ using $(\texttt{a}, \;q_1)$.
    \item The next symbol is \texttt{b}. We transition to $q_2$ using $(\texttt{b}, \;q_2)$.
    \item The next symbol is \texttt{b}. We transition to $q_2$ using $(\texttt{b}, \;q_2)$.
    \item We have no more symbols to scan. Because $q_2$ is a final state, we accept the input.
\end{enumerate}

With this in mind, what do we need to do? We want a recursive function that receives a symbol and the current state, which then scans the list of states, retrieves the state of interest, then scans its transition function for the correct next state. Let us write the template code for such a procedure.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define dfa
 ((*;$\lambda$;*) (los)
  (let* ([states los])
   (letrec ([test 
             ((*;$\lambda$;*) (sym curr-state)
              (*;\textcolor{lightgray}{$\ldots$};*))])
    ((*;$\lambda$;*) (input)
     (*;\textcolor{lightgray}{$\ldots$};*))))))
\end{lstlisting}\end{cl}

Out of simplicity, we can assume that the first state in the list of states denotes the start state. So, let us store this in a variable.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define dfa
 ((*;$\lambda$;*) (los)
  (let* ([states los]
         [start (first states)])
   (letrec ([test 
             ((*;$\lambda$;*) (sym curr-state)
              (*;\textcolor{lightgray}{$\ldots$};*))])
    ((*;$\lambda$;*) (input)
     (*;\textcolor{lightgray}{$\ldots$};*))))))
\end{lstlisting}\end{cl}

In addition to the start state, we should write a procedure that, when given a state, determines if it is a final state or not. We can do this by checking its state property field, or element, for the symbol \texttt{\textquotesingle{}f}.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define dfa
 (*;\textcolor{lightgray}{$\ldots$};*)
 (letrec ([final-state?
           ((*;$\lambda$;*) (state)
            (member? 'f (third state)))]
          [test 
           ((*;$\lambda$;*) (sym curr-state)
            (*;\textcolor{lightgray}{$\ldots$};*))])))
\end{lstlisting}\end{cl}

Now, let us write the hardest part: \texttt{test}. As we said, it receives two arguments: a symbol and a state. First, we can write the base case. That is, if the symbol is null, we can just query the current state to see if it is final, which in turn accepts or rejects the input.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define dfa
 (*;\textcolor{lightgray}{$\ldots$};*)
 (letrec ([final-state? (*;\textcolor{lightgray}{$\ldots$};*)]
          [tester 
           ((*;$\lambda$;*) (sym curr-state)
            (cond
             [(null? sym) (final-state? curr-state)]))])
  (*;\textcolor{lightgray}{$\ldots$};*)))
\end{lstlisting}\end{cl}

Otherwise, we extract the transitions from the current state, and at the same time, find the next state. We can use a helper function \texttt{assv}, which receives a symbol and an association list. For example:

\begin{cloast}[]{}
\begin{lstlisting}[language=MyScheme]
(define assv
 ((*;$\lambda$;*) (obj ls)
  (cond
   [(null? ls) #f]
   [else
    (let ([binding (first ls)])
     (cond
      [(eqv? (first binding) obj) 
       binding]
      [else (assv obj (rest ls))]))])))

(*;\textbf{>};*) (assv (*;\textquotesingle;*)b (*;\textquotesingle;*)((a . 1) (b . 2) (c . 3)))
(*;\textbf{>};*) (assv (*;\textquotesingle;*)z (*;\textquotesingle;*)((a . 1) (b . 2) (c . 3)))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]











(b . 2)
#f
\end{lstlisting}
\end{cloast}

\noindent Therefore, we make the necessary changes in the \ttt{dfa} local definition of \ttt{tester}:

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define dfa
 (*;\textcolor{lightgray}{$\ldots$};*)
 (letrec ([(*;\textcolor{lightgray}{$\ldots$};*)]
          [tester 
           ((*;$\lambda$;*) (sym curr-state)
            (cond
             [(null? sym) (final-state? curr-state)]
             [else
              (let* ([transitions (second curr-state)]
                     [next (assv (first sym) transitions)])
               (*;\textcolor{lightgray}{$\ldots$};*))]))])
  (*;\textcolor{lightgray}{$\ldots$};*)))
\end{lstlisting}\end{cl}

\noindent With these fields, we can re-invoke \texttt{tester} with the next symbol and state respectively.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define dfa
 (*;\textcolor{lightgray}{$\ldots$};*)
 (letrec ([(*;\textcolor{lightgray}{$\ldots$};*)]
          [tester 
           ((*;$\lambda$;*) (sym curr-state)
            (cond
             [(null? sym) (final-state? curr-state)]
             [else
              (let* ([transitions (second curr-state)]
                     [next (assv (first sym) transitions)])
               (tester (rest sym) (assv (second next) states)))]))])
  (*;\textcolor{lightgray}{$\ldots$};*)))
\end{lstlisting}\end{cl}

Notice that \texttt{next} is the transition pair, of the form \texttt{\textquotesingle(sym state)}, used to get to the subsequent state from \texttt{curr-state}. Finally, in the invocation to \texttt{tester}, we call \texttt{assv} on the snd of \texttt{next}, which is a state identifier. The recursive calls continue until \texttt{s} is empty. The last piece of the puzzle is to add a lambda function into the body of the \texttt{letrec} which invokes \texttt{tester} with the input argument and the start state \texttt{start}.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define dfa
 ((*;$\lambda$;*) (los)
  (let* ([states los]
         [start (first states)])
   (letrec ([final-state?
             ((*;$\lambda$;*) (state)
              (member? 'f (third state)))]
            [tester 
             ((*;$\lambda$;*) (sym curr-state)
              (cond
               [(null? sym) (final-state? curr-state)]
               [else
                (let* ([transitions (second curr-state)]
                       [next (assv (first sym) transitions)])
                 (tester (rest sym) (assv (second next) states)))]))])
    ((*;$\lambda$;*) (input)
     (tester input q0))))))
\end{lstlisting}\end{cl}

\noindent Now, let us construct the DFA from earlier, using the familiar syntax.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define d1 (dfa (*;\textquotesingle;*)((q0 ((a . q1) (b . q2)) (s))
                  (q1 ((a . q1) (b . q2)) ())
                  (q2 ((a . q2) (b . q2)) (f))))
\end{lstlisting}\end{cl}

If we output \texttt{d1}, we see it displays as a function, which makes sense because the returned expression is the \texttt{lambda} which receives \texttt{input} and invokes \texttt{tester}. So, let us invoke this with a few tests.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNScheme]
(*;\textbf{>};*) (d1 (*;\textquotesingle;*)(a))
(*;\textbf{>};*) (d1 (*;\textquotesingle;*)(b))
(*;\textbf{>};*) (d1 (*;\textquotesingle;*)(a b))
(*;\textbf{>};*) (d1 (*;\textquotesingle;*)(a a a a a a a))
(*;\textbf{>};*) (d1 (*;\textquotesingle;*)(b a a a b a b))
(*;\textbf{>};*) (d1 (*;\textquotesingle;*)(a a a a a a b))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
#f
#t
#t
#f
#t
#t
\end{lstlisting}
\end{cloast}

We can, visually, explain the language described by this DFA. It is the language of \texttt{a}'s and \texttt{b}'s such that the input contains at least one \texttt{b}. This is evident by test cases 1 and 4. As another example, let us write the code to represent the following DFA:

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,semithick]
    \node[state, accepting, initial] (q1) {$q_1$};
    \node[state, accepting, right of=q1] (q2) {$q_2$};
    \node[state, below of=q1] (q3) {$q_3$};
    \node[state, accepting, below of=q2] (q4) {$q_4$};
    
    \draw (q1) edge[loop above] node{$a$} (q1)
          (q1) edge[bend left, above] node{$b$} (q2)
          (q2) edge[bend left, above] node{$a$} (q3)
          (q2) edge[bend left, above] node{\hspace{1em}$b$} (q4)
          (q3) edge[loop left] node{$a$} (q3)
          (q3) edge[bend left, below] node{$b$} (q2)
          (q4) edge[loop right] node{$b$} (q4)
          (q4) edge[bend left, below] node{$a$} (q3);
\end{tikzpicture}
\end{center}
\caption{Simple DFA Example \#2.}
\label{fig:dfanest2}
\end{figure}

Going from a diagram, it is trivial to describe the transitions and state properties. We quickly run into a severe problem, though! The start state is also a final state, which means that the DFA accepts the empty string. So, what do we do in this case? Our code currently runs under the assumption that the first state is guaranteed to be the start state. So, why do we need a property that says if it is the starting state? It is, effectively, superfluous. So, if the starting state is also a final state, we can simply mark it as final and be rid of the \textquotesingle\texttt{s} tag.

With this modification, an accurate description of the DFA is possible.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyScheme]
(define d2 
 (dfa (*;\textquotesingle;*)((q1 ((a . q1) (b . q2)) (s f))
        (q2 ((a . q3) (b . q4)) (f))
        (q3 ((a . q3) (b . q1)) ())
        (q4 ((a . q3) (b . q4)) (f)))))

(*;\textbf{>};*) (d2 (*;\textquotesingle;*)())
(*;\textbf{>};*) (d2 (*;\textquotesingle;*)(a b))
(*;\textbf{>};*) (d2 (*;\textquotesingle;*)(b a))
(*;\textbf{>};*) (d2 (*;\textquotesingle;*)(a a a a a))
(*;\textbf{>};*) (d2 (*;\textquotesingle;*)(b b a a))
(*;\textbf{>};*) (d2 (*;\textquotesingle;*)(b b a a b))
(*;\textbf{>};*) (d2 (*;\textquotesingle;*)(b b a b b a))
(*;\textbf{>};*) (d2 (*;\textquotesingle;*)(a a a b b))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]






#t
#t
#f
#t
#f
#t
#f
#t
\end{lstlisting}
\end{cloast}

Hopefully, the pattern in the accepted language is apparent---this DFA accepts all strings that are either empty, only contain \texttt{a}'s, or end with \texttt{b}.

\exercise{1}{chapter-functional}{Describe the language of strings that the following automaton accepts, then encode it into the interpreter.}
\begin{figure}[H]
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,semithick]
    \node[state, initial] (q1) {$q_1$};
    \node[state, below right of=q1] (q2) {$q_2$};
    \node[state, accepting, above right of=q2] (q3) {$q_3$};
    
    \draw (q1) edge[bend left] node{$a,\;b$} (q3)
          (q2) edge[loop below, below] node{$a,\;b$} (q2)
          (q3) edge[bend left, above] node{$a$} (q1)
          (q3) edge[bend left, above] node{$b$} (q2);
\end{tikzpicture}
\end{center}
\caption{Simple DFA Example \#3.}
\label{fig:dfanest3}
\end{figure}

\clearpage
\subsection*{\nestedlang{TURING}: Simulating a Turing Machine}

It is astounding how little computing power is necessary to do ``heavy-duty'' tasks. Of course, said tasks may take a seemingly infinite amount of time to complete, but nonetheless, given enough time, they terminate. In this section, we will minimize our programming syntax and semantics to support only two symbols, natural numbers, and small data stores called registers. This language will be aptly named after Alan Turing\index{Alan Turing}: \nestedlang{TURING}\index{\nestedlang{TURING}}. While not an exact replicate of the formal definition of a Turing machine, its capabilities mimic the power of one.

\nestedlang{TURING} recognizes two symbols: `+' and `-'. These are the only storable symbols. Said symbols are storable in \textit{registers}\index{register}, identified by positive integers, e.g., 1, 2, and so on. For example, to add a `+' to register 1, we use the command \texttt{(1 (+))}. If we want to store the symbols `-', `-', `+', `-', `-' in register 2, we use \texttt{(2 (- - + - -))}. Each insertion is issued as a \textit{cons} pair whose \textit{first} is the identifying register and whose \textit{second} is a list of symbols to add to the end of the register contents. Instructions are executed sequentially, and each instruction is stored in a list. Take the following program which stores a binary representation of the corresponding register identifier in the register for registers 1 to 5, interpreting `\ttt{+}' as one and `\ttt{-}' as zero. The output window shows the environment representation, which is nothing more than an association list of registers mapped to their contents. 

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNScheme]
'((1 (+))
  (2 (+ -))
  (3 (+ +))
  (4 (+ - -))
  (5 (+ - +)))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
((1 . (+)) (2 . (+ -)) (3 . (+ +)) 
 (4 . (+ - -)) (5 . (+ - +)))
\end{lstlisting}
\end{cloast}

As it would appear, this program does nothing all too interesting because it has nothing to divert program flow. Therefore, we introduce two new commands: a program counter decrementer and a program counter incrementer. The program counter is a natural number corresponding to the currently-executing instruction. After each statement is executed, the program counter increments by one, hence the sequential nature of \nestedlang{TURING}. To jump successive instructions, we use the `\texttt{>}' operator. For example, to jump three instructions ahead, we use \texttt{(> > >)} as follows.

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNScheme]
'((1 (+))
  (> > >)
  (2 (+ -))
  (3 (+ +))
  (4 (+ - -))
  (5 (+ - +)))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
((1 . +) (4 . + - -) (5 . + - +))
\end{lstlisting}
\end{cloast}

As demonstrated, we jump from instruction 2 to instruction 5. We will call this a type of redirection operator, namely a ``forward redirection''. Going the other way allows us to mimic looping semantics from other programming languages. For example, if we want to transfer control from instruction 5 back to the start of the program, we use the ``backward redirection'' operator, i.e., \texttt{<}. 

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNScheme]
'((1 (+))
  (2 (+ -))
  (3 (+ +))
  (4 (+ - -))
  (< < <)
  (5 (+ - +)))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
(*;$\bot$;*)
\end{lstlisting}
\end{cloast}

This program, as expected, never terminates; it continuously sets the values in registers 1, 2, 3, and 4. So, redirection operators serve little purpose without augmenting our language with decision structures. Our machine interprets question marks as case analyses on a register, based on its contents. We will perform case analysis via \texttt{(N ?)} where \texttt{N} is a register. If the register contains no symbols, control flow continues to the next sequential instruction. If the first value in the register is `\texttt{+}', the symbol is removed and we jump two instructions ahead. Lastly, if the first value in the register is `\texttt{-}', the symbol is removed and we jump three instructions ahead. The fact that we pop symbols off a register provides the potential to continuously make decisions that lead to a program that terminates. Of course, even though we have such a small set of operators, it remains easy to accidentally wind up in an infinite loop, just as it is in any other programming language. See Figure~\ref{fig:turingtable} for a condensed explanation of the case analysis algorithm.

\begin{figure}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \textbf{First of }\ttt{(N ?)} & \textbf{Register Behavior} & \textbf{Instruction Jump} \\
        \hline
        \ttt{\q{}()} & none & \text{Go To Next} \\
        \ttt{\q{}+} & Remove \ttt{+} from \ttt{N} & \text{Jump 2 Instructions} \\
        \ttt{\q{}-} & Remove \ttt{-} from \ttt{N} & \text{Jump 3 Instructions} \\
        \hline
    \end{tabular}
    \caption{Case Analysis Operations in \nestedlang{TURING}}
    \label{fig:turingtable}
\end{figure}

Let us write a \nestedlang{TURING} that transfers the contents from register $1$ to register $2$ using our new syntax and semantics. Because programs in \nestedlang{TURING} are somewhat offputting to non-computer readers of the language, we will supplement the program with adjacent comments. To begin, we will store an arbitrary set of input symbols inside register $1$.

\begin{clo}[]{}
\begin{lstlisting}[language=MyVOutput]
'((1 (+ - - - + - - + - +))
  (1 ?)          ; Case analysis on R1.
  (> > > > > >)  ; If |R1|=0 goto end.
  (> > >)        ; If R1 has + goto (2 (+))
  (2 (-))        ; Add - to R2.
  (< < < <)      ; Back to (1 ?).
  (2 (+))        ; Add + to R2.
  (< < < < < <)) ; Back to (1 ?).
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyVOutput]
((1) 
 (2 . + - - - + 
      - - + - +))
\end{lstlisting}
\end{clo}

On the other hand, if we want to \textit{copy} the values from register 1 into register 2, we need to use an auxiliary register that transfers contents from register 1 to register 3 while also inserting symbols into register 2. Afterwards, we remove all symbols from register 3 and insert them back into register 1 using the same idea. We cannot simply add symbols to the end of register 1 as that would cause an infinitely looping program.

\begin{clo}[]{}
\begin{lstlisting}[language=MyVOutput]
'((1 (+ - - - + - - + - +))
  ;; First, move R1 into R2.
  (1 ?)               ; Cases on R1.
  (> > > > > > > > >) ; Go to R3 copy.
  (> >)
  (> > > >)
  (3 (+))             ; Push + to R3.
  (2 (+))             ; Push + to R2.
  (< < < < < <)       ; Back to R1 case.
  (3 (-))             ; Push - to R3.
  (2 (-))             ; Push - to R2.
  (< < < < < < < < <) ; Back to R1 case.
  ;; Now copy over from r3 back to r1.
  (3 ?)               ; Cases on R3.
  (> > > > > > >)     ; Go to end.
  (> >)
  (> > >)
  (1 (+))             ; Push + to R1.
  (< < < < <)         ; Back to R3 case.
  (1 (-))             ; Push - to R1.
  (< < < < < < <)))   ; Back to R2 case.
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyVOutput]
((1 . + - - - + 
      - - + - +) 
 (3) 
 (2 . + - - - + 
      - - + - +))
\end{lstlisting}
\end{clo}

Notice that register 3 shows up in the output window, just without any contents. We could implement a procedure to remove auxiliary registers like these, i.e., registers that are used during program execution, but are empty at program termination time.

\clearpage
\subsection*{\nestedlang{DERIVATIVE}\index{\nestedlang{DERIVATIVE}}: A Symbolic Differentiator}

In calculus, the notion of the derivative of a function comes up quite frequently. Computing the derivative of a function by hand is a laborious task often reserved for introductory students. In this section, we will write a symbolic differentiator\index{symbolic differentiation}, which uses basic rules from calculus to find the derivative of a given function. \textit{Note: even if the reader has not taken a course in elementary calculus, we present the topic in a way that does not require knowledge of concepts from calculus}.

The target outcome is to be able to take the derivative of a function represented as an s-expression, e.g., $x^2\;+\;\text{cos}(\sqrt{x})$ is represented as \texttt{(+ (expt x 2) (cos (sqrt x)))}. Actually understanding what the derivative of a function is, is beyond the scope of this textbook. We, on the other hand, will apply simple rules of calculus to find the derivative of simple functions. Then, we can apply those rules on a larger problem and break it down into sub-components.

First, we need to write a evaluation function that receives expressions/functions and computes their derivative. We shall name this function \texttt{deriv-of}. For now, it just returns \ttt{\#f} since there are no dispatch clauses.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define deriv-of
 ((*;$\lambda$;*) (exp)
  (cond
   [else #f])))
\end{lstlisting}\end{cl}

Now, let us take the derivative of the simplest possible function: a constant number. 

\textbf{Derivative of a constant:} If we have a function $f=c$ where $c$ is any number, the derivative of $f$ is always zero. E.g., \texttt{(deriv-of 5)} resolves to \texttt{0}. We need to write the recognition and derivative evaluation functions for a constant.

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define constant?
 ((*;$\lambda$;*) (exp)
  (number? exp)))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define deriv-of-constant
 ((*;$\lambda$;*) (exp)
  0))
\end{lstlisting}
\end{clrr}

\textbf{Derivative of a variable:} The second-simplest function to differentiate is when the function is a single variable, e.g., $f=\phi$, where $\phi$ is any variable, e.g., $x$, $y$. The derivative of these functions is always one. E.g., \texttt{(deriv-of \textquotesingle{}x)}. The recognition and evaluation functions are just as trivial as those for differentiating constants.

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define variable?
 ((*;$\lambda$;*) (exp)
  (symbol? exp)))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define deriv-of-variable
 ((*;$\lambda$;*) (exp)
  1))
\end{lstlisting}
\end{clrr}

\textbf{Derivative of a Sum/Difference:} To compute the derivative of the sum/difference of two functions $f$ and $g$, namely $f \pm g$, we differentiate $f$ and $g$ independently, then either add or subtract the values. E.g., \texttt{(deriv-of \textquotesingle(+ (+ (+ x x) x) (+ 5 x)))} resolves to \texttt{8} because the derivative of \texttt{(+ (+ x x) x)} is \texttt{3}, and the derivative of \texttt{(+ 5 x)} is 1. When differentiating a sum/difference, we need to create a sum/difference expression. We can create two local functions \texttt{make-sum} and \texttt{make-difference} that receive two expression functions $f$ and $g$, and resolves them based on their values. We can utilize useful properties of addition and subtraction to ``fold'' the expressions. For instance, \texttt{(+ x 0)} is equivalent to \texttt{x}. Another example is \texttt{(- 13 6)} which resolves to \texttt{7}. If we cannot ``fold'' an expression, we just return it as a sum/difference list.

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define sum?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 3)
       (eqv? (first exp) '+))))
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define deriv-of-sum
 ((*;$\lambda$;*) (exp)
  (let ([f (deriv-of (second exp))]
        [g (deriv-of (third exp))])
   (let 
    ([make-sum
      ((*;$\lambda$;*) (f g)
       (cond
        [(and (number? f) (zero? f)) g]
        [(and (number? g) (zero? g)) f]
        [(and (number? f) (number? g)) 
         (+ f g)]
        [else (*;\qq;*)(+ ,f ,g)]))])
    (make-sum f g)))))
\end{lstlisting}
\end{clrr}

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define difference?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 3)
       (eqv? (first exp) '-))))
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define deriv-of-difference
 ((*;$\lambda$;*) (exp)
  (let ([f (deriv-of (second exp))]
        [g (deriv-of (third exp))])
   (let 
    ([make-difference
      ((*;$\lambda$;*) (f g)
       (cond
        [(and (number? f) 
              (number? g) 
              (zero? f)) 
         (- g)]
        [(and (number? g) (zero? g)) f]
        [(and (number? f) (number? g)) 
         (- f g)]
        [else (*;\qq;*)(- ,f ,g)]))])
    (make-difference f g)))))
\end{lstlisting}
\end{clrr}

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNScheme]
(*;\textbf{>};*) (deriv-of '(+ (+ (+ x x) x) (+ 5 x)))
(*;\textbf{>};*) (deriv-of '(- 5 x))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]   
8
1
\end{lstlisting}
\end{cloast}

\textbf{Derivative of a Product:} Differentiating a product, e.g., $f \cdot g$, is ever-so-slightly more difficult than sum and difference derivatives. The derivative of such a product is $(f\cdot g') + (f' \cdot g)$ where $f'$ and $g'$ are the derivatives of $f$ and $g$ respectively. So, we can write the relevant recognition and reducer pair. Just like \texttt{make-sum} and \texttt{make-difference}, we will create a \texttt{make-product} that folds constants, zeroes out expressions that multiply by zero, and eliminates multiplications by one. With these, we can write \texttt{deriv-of-product}, which makes use of the previously-implemented functions.

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define product?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 3)
       (eqv? (first exp) '*))))
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define deriv-of-product
 ((*;$\lambda$;*) (exp)
  (let ([f (second exp)]
        [g (third exp)])
   (let 
    ([make-product
      ((*;$\lambda$;*) (f g)
       (cond
        [(and (number? f) (zero? f)) 0]
        [(and (number? g) (zero? g)) 0]
        [(and (number? f) (= f 1)) g]
        [(and (number? g) (= g 1)) f]
        [(and (number? f) (number? g)) 
         (* f g)]
        [else (*;\qq;*)(* ,f ,g)]))])
    (make-sum
     (make-product (deriv-of f) g)
     (make-product (deriv-of g) f))))))
\end{lstlisting}
\end{clrr}

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNScheme]
(*;\textbf{>};*) (deriv-of '(- (* 5 x) (* 11 x)))
(*;\textbf{>};*) (deriv-of '(+ (* (* 3 x) x) (* 9 x)))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
-6
(+ (+ (* 3 x) (* 3 x)) 
   9)
\end{lstlisting}
\end{cloast}

\textbf{Derivative of a Quotient:}
Opposite to products, we will now differentiate division, or quotients. The derivative of a quotient, $f/g$, is $((f\cdot{g'})\;-\;(f'\cdot{g}))/(g^2)$. So, as we can see, it is eerily similar to differentiating a product with two modifications: we subtract the right-hand side from the left (instead of addition), and divide the difference by $g$ squared, or $g\cdot{g}$. Let us write the recognition/reducer functions as well as \texttt{make-quotient}. 

\begin{clrr}[]{}\begin{lstlisting}[language=MyScheme]
(define quotient?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 3)
       (eqv? (first exp) '/))))
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define deriv-of-quotient
 ((*;$\lambda$;*) (exp)
  (let* ([f (second exp)]
         [g (third exp)]
         [df (deriv-of f)]
         [dg (deriv-of g)])
   (let
    ([make-quotient
      ((*;$\lambda$;*) (f g)
       (cond
        [(and (number? f) (zero? f)) 0]
        [(and (number? f) (number? g)) 
         (/ f g)]
        [else (*;\qq;*)(/ ,f ,g)])))]
   (make-quotient
    (make-difference 
     (make-product df g)
     (make-product dg f))
    (make-product g g))))))
\end{lstlisting}
\end{clrr}

\begin{cloast}[]{}
\begin{lstlisting}[language=MyNLNScheme]
(*;\textbf{>};*) (deriv-of '(/ 1 x))
(*;\textbf{>};*) (deriv-of '(/ 1 (make-product x x)))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNSOutput]
(/ -1 (* x x))
(/ (- 0 (+ x x)) 
   (* (* x x) 
      (* x x)))
\end{lstlisting}
\end{cloast}

\textbf{Derivative of a (Simple) Exponent:}
The last function ``class'' that we will implement is a simple exponential. A simple exponential takes the form $\phi^n$ where $\phi$ is any variable and $n$ is any integer. E.g., \texttt{(expt x 2)} is a simple exponent, but \texttt{(expt (cos x) 4)} is not. The derivative of a simple exponential is ${n\cdot{x}^{n-1}}$. E.g., the derivative of $x^5$ is $5\cdot{x}^{4}$. Let us write the accompanying recognition/reducer pair and ``make'' function. Note that we can make use of some simple algebraic rules to fold exponentials, e.g., $x^0=1$, $x^1=x$, and $0^n=0$ for any $n>0$. 

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(define expt?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 3)
       (symbol? (second exp))
       (eqv? (first exp) 'expt))))
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
(*;\phantom{.};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(define deriv-of-expt
 ((*;$\lambda$;*) (exp)
  (let ([base (second exp)]
        [power (third exp)])
   (let 
    ([make-expt
      ((*;$\lambda$;*) (f g)
       (cond
        [(and (number? f) (zero? f)) 0]
        [(and (number? g) (zero? g)) 1]
        [(and (number? g) (= g 1)) f]
        [(and (number? f) (number? g)) 
         (expt f g)]
        [else (*;\qq;*)(expt ,f ,g)]))))
    (make-expt 
     (make-product power base)
     (sub1 power))))))
\end{lstlisting}
\end{clrr}

\begin{cloast}[]{}\begin{lstlisting}[language=MyNLNScheme]
(*;\textbf{>};*) (deriv-of '(expt x 3))



(*;\textbf{>};*) (deriv-of '(* 4 (expt x 3))



(*;\textbf{>};*) (deriv-of '(/ (* 2 x) (expt x 2)))



(*;\textbf{>};*) (deriv-of '(/ (- (* 3 x) 4) 
                (- (* 2 (expt x 2)) 
                   1)))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MySOutput]
(expt (* 3 x) 2)



(* (expt (* 3 x) 2) 4)



(/ (- (* 2 (expt x 2)) 
      (* (* 2 x) (* 2 x))) 
   (expt (expt x 2) 2))
   
(/ (- (* 3 (- (* 2 (expt x 2)) 1)) 
      (* (* (* 2 x) 2) 
         (- (* 3 x) 4))) 
   (expt (- (* 2 (expt x 2)) 1) 2))
\end{lstlisting}
\end{cloast}

\exercise{2}{chapter-functional}{Write two functions: \texttt{deriv-of-sqrt} and \texttt{deriv-of-log}, which take the derivative of square roots and base ten logarithms respectively. The derivative of a square root function is $(1/2) \cdot (f' / \sqrt{(f)})$ where $f$ is some function. The derivative of a base ten logarithmic function is $f'/f$ where $f$ is some function.}

\exercise{1}{chapter-functional}{Write two functions: \texttt{deriv-of-sin} and \texttt{deriv-of-cos}, which take the derivative of the sine and cosine functions respectively. The derivative of the sine function is $f'\cdot \text{cos}(f)$, where $f$ is some function. The derivative of the cosine function is $f'\cdot -\text{sin}(f)$.}

\exercise{2}{chapter-functional}{Write a function: \texttt{deriv-of-tan} which takes the derivative of the tangent function. The derivative of the tangent function is $1+\text{tan}^2(f)\cdot f'$, where $f$ is some function.}

\exercise{2}{chapter-functional}{Turn the addition and subtraction functions, namely \texttt{+} and \texttt{-} into functions that use any number greater than or equal to two of arguments. That is, allow differentiation of functions such as \texttt{(deriv-of (+ 5 6 7 8 $\ldots$))}.}

\clearpage
\subsection*{\nestedlang{PROOF}: Natural Deduction Proof Checker}
In Chapter~\ref{chapter-maths}, we dedicated an entire section to propositional logic and its significance in the world of computer science. Along those lines, we also discussed proof techniques, one of which was natural deduction. In this section, we will write \nestedlang{PROOF}\index{\nestedlang{PROOF}}: a nested interpreter that determines whether or not a given natural deduction propositional logic proof is valid.

Let us look at a sample PL proof to see what we are getting into. We will then explain our encoding scheme to translate the proof into a representation understandable by \nestedlang{PROOF}.

\begin{tabular}{ l l l r }
    1. & $p$ $\lor$ $q$ & Premise   & \\
    2. & $\lnot{p}$      & Premise   & \\
    3. & $q$ $\to$ $r$  & Premise   & \\
    4. & $q$            & 1, 2      & DS \\
    5. & $r$            & 3, 4      & MP \\
    6. & $q$ $\land$ $r$ & 4, 5     & $\land$-Intro
\end{tabular}

A natural deduction proof, as we have shown, contains premises and derivation steps. At each step, we may apply a rule that follows from previous steps. Let us envision a prefix encoding of this proof:
\begin{cl}[]{}\begin{lstlisting}[language=MySOutput]
'(proof 
  ((or (atom p) (atom q)) () Premise)
  ((not (atom q)) () Premise)
  ((implies (atom q) (atom r)) () Premise)
  ((atom q) (1 2) DS)
  ((atom r) (3 4) MP)
  ((and (atom q) (atom r)) (4 5) ConjIntro))
\end{lstlisting}\end{cl}
We encode a proof as a list of elements described by steps. Namely, a step is a list that contains three elements: the \textit{first} is the proposition declared by the step, the \textit{second} is a list of (previous) steps used in the derivation of its proposition, and the \textit{third} is the step ``type''. Our goal is to take a proof written in this format and output whether it is a valid proof or not. An invalid proof is one that, at some point, incorrectly defines a step.

To start, we should implement a large evaluation function, i.e., \texttt{check}, which receives a step using the aforementioned format and delegates evaluation of each component via case analysis. It also receives the proof as a whole. We will come back to explain the motivation behind this choice soon.
\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define check
 ((*;$\lambda$;*) (step proof)
  (cond
   [(rule-premise? step) (check-rule-premise step proof)]
   [(rule-mp? step) (check-rule-mp step proof)]
   [(*;\textcolor{lightgray}{$\ldots$};*)]
   [else #f])))
\end{lstlisting}\end{cl}

Now, we can write the accompanying recognition functions. We will categorize our recognition functions based on the type of recognizer. Namely, we have propositions and rules. Rules consist of propositions, meaning we should write the proposition recognizers first. For simplicity, we will only show the implementation of two recognizers. As a data definition, we say that propositions are implemented as a list where the \textit{first} is the ``type'' of proposition, i.e., an implication, conjunction, atom, and so on. The remaining elements are arguments to the connective or proposition type. 

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define prop-atom?
 ((*;$\lambda$;*) (p)
  (and (cons? p)
       (= (length p) 2)
       (eqv? (first p) 'atom))))

(define prop-implies?
 ((*;$\lambda$;*) (p)
  (and (cons? p)
       (= (length p) 3)
       (eqv? (first p) 'implies))))
\end{lstlisting}\end{cl}
Next, we can write the ``rule'' recognizers. Rules act as derivation steps in a proof, as we described earlier. Fortunately, these are almost identical to the \texttt{prop-} recognizers.
\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define rule-premise?
 ((*;$\lambda$;*) (step)
  (and (cons? step)
       (= (length step) 3)
       (eqv? (third step) 'Premise))))

(define rule-mp?
 ((*;$\lambda$;*) (step)
  (and (cons? step)
       (= (length step) 3)
       (= (length (second step)) 2)
       (eqv? (third step) 'MP))))
\end{lstlisting}\end{cl}
Note that we do not implement reducers for \texttt{prop-} recognizers as there is no need; we simply use these recognizers in tandem when invoking \texttt{check-rule-} reducers. Speaking of those reducers, let us write those! \texttt{check-rule-} reducers return a boolean value that designates whether the rule was applied correctly or incorrectly. Premises are trivial and are always, by definition, applied correctly. So, we will jump directly to \texttt{check-rule-mp}. All reducers receive two arguments: the step that it evaluates on, and the entire proof as a list. We need this because we must verify that derivation steps were applied correctly. So, when we reference a step in the \textit{second} list, we retrieve it from the proof using a naturally recursive function 
\texttt{get-proof-step}.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define get-proof-step
 ((*;$\lambda$;*) (step proof)
  (cond
   [(null? proof) #f]
   [(= step 1) (first proof)]
   [else (get-proof-step (- step 1) (rest proof))])))
      
(define check-rule-mp
 ((*;$\lambda$;*) (mp proof)
  (let* ([steps (second mp)]
         [s1 (first (get-proof-step (first steps) proof))]
         [s2 (first (get-proof-step (second steps) proof))])
   (*;\textcolor{lightgray}{$\ldots$};*))))
\end{lstlisting}\end{cl}

We verify three properties when determining if a \texttt{MP} rule was correctly applied: if \texttt{s1} is an implication, if the antecedent of \texttt{s1} is equal to \texttt{s2}, and if the consequent of \texttt{s2} is equal to the proposition defined by the step. Consider the following example.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
'(((implies (atom p) (atom q)) () Premise)
  ((atom p) () Premise)
  ((atom q) (1 2) MP)))
\end{lstlisting}\end{cl}

When we encounter the final step of this proof, we see that it uses MP. So, we look up the steps used in its derivation, namely \texttt{1} and \texttt{2}. One thing that we have yet to define is \texttt{prop-=?}: a predicate that determines if two propositions are the same. Two \texttt{prop-atom?} are the same if they share the same proposition atom. Two \texttt{prop-implies?} are the same if, according to \texttt{prop-=?}, their antecedents are equivalent and their consequents are equivalent.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define prop-=?
 ((*;$\lambda$;*) (p1 p2)
  (cond
   [(and (prop-atom? p1) (prop-atom? p2)) 
    (eqv? (second p1) (second p2))]
   [(and (prop-implies? p1) (prop-implies? p2)) 
    (and (prop-=? (first p1) (first p2)) (prop-=? (second p1) (second p2)))]
   [else #f])))
\end{lstlisting}\end{cl}

\noindent We may now use this equality checker in \texttt{check-rule-mp}.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define check-rule-mp
 ((*;$\lambda$;*) (mp proof)
  (let* ((*;\textcolor{lightgray}{$\ldots$};*))
   (and (prop-implies? s1)
        (prop-=? (second s1) s2)
        (prop-=? (third s1) (first mp))))))
\end{lstlisting}\end{cl}

Finally, we need a way of traversing through the proof to analyze each rule one at a time sequentially. As we have repeatedly seen, the best approach is to use \texttt{letrec} that localizes the recursion. Recall that we want to return \texttt{\#t} if the proof is correct and \texttt{\#f} otherwise. Our base case is simple: if we have reached the end of the proof, then every step prior must be correct, so the collective proof is correct. We then check each step in succession. If we encounter a check that returns \texttt{\#t}, we continue checking the remaining steps. Upon encountering an incorrectly-applied rule, we return \texttt{\#f}. 

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define check-proof
 (letrec ([checker 
           ((*;$\lambda$;*) (step proof)
            (cond
             [(null? step) #t]
             [(eqv? (check (first step) proof) #t)
              (checker (rest step) proof)]
             [else #f]))])
  ((*;$\lambda$;*) (proof)
   (checker proof proof))))
\end{lstlisting}\end{cl}

Let us try a very simple example: one that only uses atoms as the antecedent and conclusion of an implication.

\begin{clo}[]{}
\begin{lstlisting}[language=MyScheme]
(define pf1 
 '(((implies (atom p) (atom q)) () Premise)
   ((atom p) () Premise)
   ((atom q) (1 2) MP)))

(*;\textbf{>};*) (check-proof pf1)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]





#t
\end{lstlisting}
\end{clo}

% \subsection*{\nestedlang{WEB}: Webpage Generator}
% Web development has, in the last few decades, exploded in popularity. Though, the days of writing, say, HTML and CSS by hand are largely gone. Instead, developers use tools  to build websites. In addition to the multitude of available drag-and-drop platforms for website design, e.g., WordPress, there exist programming languages that build websites using the constructs of that language. For instance, the Racket programming language has Scribble: a framework for designing webpages and documents. In this section, we will write \nestedlang{WEB}: a nested interpreter for designing very basic webpages.

% A background in HTML and CSS is not necessary, as we will go through the relevant material while building the interpreter. The idea is simple: use \nestedlang{WEB} to output HTML code for a webpage using functions and lists. As an example, let us investigate the code for a standard HTML ``Hello, world!'' webpage.

% \todo{change this to an HTML listing..!}
% \begin{cl}[]{}\begin{lstlisting}[language=MyC]
% <!DOCTYPE html>
% <html>
%   <head>
%     <meta charset="utf-8" />
%     <title>Hello World Page</title>
%   </head>
%   <body>
%     <h1>Hello, world!</h1>
%   </body>
% </html>
% \end{lstlisting}\end{cl}

% As we see, we have a series of tags that define pieces of the webpage. With this in mind, it would be convenient to not have to go through the trouble of writing opening and closing tags. Also, as the webpage grows in complexity, finding and debugging errors can be quite frustrating. Let us envision what this might look like.

% \begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
% (define genhtml
%  ((*;$\lambda$;*) (tag)
%   (cond
%    [(root? tag) (genroot tag)]
%    [(info? tag)(geninfo tag)]
%    [(*;\textcolor{lightgray}{$\ldots$};*)])))
% \end{lstlisting}\end{cl}

% Where we may invoke \texttt{genhtml} with the following content.

% \begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
% (root
%  (info ((title . "My First Page")
%   ((*;\textcolor{lightgray}{$\ldots$};*))))
%  (header ((text . "Hello, world!")
%   (size . 1)
%   (align . "center"))))
% \end{lstlisting}\end{cl}

% Each tag is represented as a list of elements where the \textit{first} is the tag type and the \textit{rest} is data associated with the tag. Different tags may have different associated data. For instance, the \texttt{info} acts as the preamble for a page, providing information about its title, character encoding, and outside content linking (as a means of integrating this with HTML context, our \texttt{info} tag corresponds directly with the HTML \texttt{head} tag). As another example, the ``header'' tag's \textit{rest} is an association list with two required attributes: text and size. Any remaining association pairs are considered ``styles'' to the tag (\texttt{header} is analogous to \texttt{h1}, \texttt{h2}, $\ldots$, and \texttt{h6}). 

% \todo{CONTINUE$\ldots$}

\clearpage
\subsection*{\nestedlang{CONTINUATION}: A Continuation-Passing Style Interpreter}
In a prior section, we mentioned the intricacies of continuations and continuation-passing style. In this section, we will revise and extend \nestedlang{PROC} into \nestedlang{CONTINUATION}\index{\nestedlang{CONTINUATION}}: a language that supports continuations and the illustrious \texttt{call/cc}\index{\ttt{call/cc}} operator.

Our discussion on continuations was driven entirely by manual continuation development. What we mean by this is that we wrote functions in explicit continuation-passing style to exhibit the potential of continuations. Some languages, however, come with built-in support for working with continuations. Scheme is one of these languages with the \texttt{call/cc}, or \texttt{call-with-current-continuation}\index{\ttt{call-with-current-continuation}} operator. Unlike our current implementation of continuations, \texttt{call/cc} allows us to ``jump out'' of a piece of code, terminating any subsequent expressions. For instance, consider the following code:
\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define foo-callcc
 (+ 2 (call/cc
       ((*;$\lambda$;*) (k)
        (* 2 (k 3) 5)))))
\end{lstlisting}\end{cl}
\texttt{call/cc} inserts a ``hole'', of sorts, into the outer addition expression, producing \texttt{(+ 2 ???)}. The \texttt{???} is a \texttt{call/cc} invocation. So, we look inside its definition to see if the continuation, namely \texttt{k}, is invoked with an expression. If so, the \texttt{???} is replaced by this value. Since we call \texttt{k} with \texttt{3}, we substitute \texttt{???} by \texttt{3}, resulting in \texttt{(+ 2 3)}, which is of course \texttt{5}. What is significant about \texttt{call/cc} is, like our continuation-passing style exception-handling technique, it stops all subsequent expression evaluation. In the above example, the body of the function passed to \texttt{call/cc} is a multiplication of \texttt{2}, \texttt{(k 3)}, and \texttt{5}. Because we invoke the continuation, the multiplication step never finishes. 

So, can we write a nested interpreter to implement \texttt{call/cc}? Certainly! We first need to rewrite our previous interpreter, namely \nestedlang{PROC}, in continuation-passing style.

All functions written in CPS must be tail recursive\index{tail recursive}, as we previously described. So, let us start by supporting a subset of \nestedlang{PROC} and working our way up. To start, all functions that are written in CPS must receive the extra continuation argument.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-cps
 ((*;$\lambda$;*) (exp env k)
  (cond
   [(number? exp) (*;\textcolor{lightgray}{$\ldots$};*)]
   [(symbol? exp) (*;\textcolor{lightgray}{$\ldots$};*)]
   [(add? exp) (*;\textcolor{lightgray}{$\ldots$};*)]
   [(lambda? exp) (*;\textcolor{lightgray}{$\ldots$};*)]
   [(application? exp) (*;\textcolor{lightgray}{$\ldots$};*)])))
\end{lstlisting}\end{cl}

The idea is to apply the continuation \texttt{k} wherever the original interpreter resolves to a value. For example, in the \texttt{number?} clause, it resolves to \texttt{exp}, meaning we should apply \texttt{k} to \texttt{exp}, treating the continuation as a function.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-cps
 ((*;$\lambda$;*) (exp env k)
  (cond
   [(number? exp) (k exp)]
   [(*;\textcolor{lightgray}{$\ldots$};*)])))
\end{lstlisting}\end{cl}

As a quick preview, let us write a test case to see what this design paradigm entails. The initial call to \texttt{value-of-cps} should receive the empty continuation, i.e., the identity function.

\begin{clo}[]{}\begin{lstlisting}[language=MyScheme]
(*;\textbf{>};*) (value-of-cps '5 (empty-env) ((*;$\lambda$;*) (v) v))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
5
\end{lstlisting}
\end{clo}

Analyzing the trace of this function shows that when we arrive at the \texttt{number?} case, we apply the continuation to the expression, resulting in \texttt{((lambda (v) v) 5)}, thus resolving to \texttt{5}.

Symbol evaluation works the same---apply the continuation onto the result of calling \texttt{apply-env}.

Addition is where things get a bit more complicated. Recall that we said a function written in CPS must be tail recursive\index{tail recursive}. Well, \texttt{value-of-add-cps} is not directly tail recursive\index{tail recursive}, but is what we will refer to as mutually-tail recursive. In essence, \texttt{value-of-cps} calls \texttt{value-of-add-cps}, which calls \texttt{value-of-cps}. We could, technically, inline the recognizer \texttt{value-of-add-cps} into the root evaluator; we choose not to out of code cleanliness. 

First, we extract the two operands of \texttt{+} out of the expression and evaluate them in accordance to continuation-passing style semantics.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-add-cps
 ((*;$\lambda$;*) (exp env k)
  (let ([v1 (second exp)]
        [v2 (third exp)])
   (value-of-cps v1 env
    ((*;$\lambda$;*) (res-v1)
     (value-of-cps v2 env
      ((*;$\lambda$;*) (res-v2)
       (k (+ res-v1 res-v2)))))))))
\end{lstlisting}\end{cl}

The lambda reducer applies the continuation to a function of \textit{two} arguments rather than one. We must explicitly pass a continuation in addition to the function argument. Otherwise, everything is the same as the non-CPS'd interpreter.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-lambda-cps
 ((*;$\lambda$;*) (exp env k)
  (let* ([loparam (second exp)]
         [x (first loparam)]
         [body (third exp)])
   (k
    ((*;$\lambda$;*) (arg k^)
     (value-of-cps body (extend-env x arg env) k^))))))
\end{lstlisting}\end{cl}

Application reduction, to the surprise of some readers, does not invoke the continuation. The reason is simple: function application ultimately reduces to one of the other cases that apply the continuation on its result. Therefore, applying the continuation onto the result of an application is redundant.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-application-cps
 ((*;$\lambda$;*) (exp env k)
  (let ([rator (first exp)]
        [rand (second exp)])
   (value-of-cps rator env
    ((*;$\lambda$;*) (rat)
     (value-of-cps rand env
      ((*;$\lambda$;*) (ran)
       (rat ran k))))))))
\end{lstlisting}\end{cl}

\noindent Let us throw a few tests at this interpreter:

\begin{clo}[]{}\begin{lstlisting}[language=MySOutput]
(*;\textbf{>};*) (value-of-cps 
   '(+ ((lambda (x) (+ x x)) 10)
       ((lambda (x) (+ x (+ x x))) 20))
   (empty-env)
   ((*;$\lambda$;*) (v) v))

(*;\textbf{>};*) (value-of-cps
   '((((lambda (x)
        (lambda (y)
         (lambda (z) (+ x (+ y z))))) 10) 20) 30)
   (empty-env)
   ((*;$\lambda$;*) (v) v))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
80





60
\end{lstlisting}
\end{clo}

The interpreter works as intended. It is now time, at long last, to implement \texttt{call/cc}. Let us write a few tests that show how it works:

\begin{clo}[]{}
\begin{lstlisting}[language=MySOutput]
(*;\textbf{>};*) (value-of-cps
   '(call/cc (lambda (k) (+ 2000000 (k 5))))
   (empty-env)
   ((*;$\lambda$;*) (v) v))

(*;\textbf{>};*) (value-of-cps
   '(+ 10
       (+ (call/cc (lambda (k) 
                    (+ 10 (+ (k 20) 30))))
          30))
   (empty-env)
   ((*;$\lambda$;*) (v) v))

(*;\textbf{>};*) (value-of-cps
   '(+ 10
       (+ (call/cc (lambda (k) (+ 10 (+ 20 30))))
          30))
   (empty-env)
   ((*;$\lambda$;*) (v) v))

(*;\textbf{>};*) (value-of-cps
   '(+ 10
       (call/cc 
        (lambda (k)
         (+ (call/cc 
             (lambda (k^)
              (+ 10 (+ 20 (k 30))))) 
            9000))))
   (empty-env)
   ((*;$\lambda$;*) (v) v))

(*;\textbf{>};*) (value-of-cps
   '(+ 10
       (call/cc
        (lambda (k)
         (+ 20 30))))
   (empty-env)
   ((*;$\lambda$;*) (v) v))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
5




60







100






40










60
\end{lstlisting}
\end{clo}

Let us begin by writing the recognizer; all we need to check for is that the \textit{first} is \texttt{call/cc}.

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define callcc?
 ((*;$\lambda$;*) (exp)
  (and (cons? exp)
       (= (length exp) 2)
       (eqv? (first exp) 'call/cc))))
\end{lstlisting}\end{cl}

Its reducer is the most complex we have seen yet. Here's the idea: the expression to \texttt{call/cc} is a procedure of one argument representing the continuation. Evaluating this function (body) in CPS gets us, of course, a continuation \texttt{k\^{}}. We should apply said continuation onto a procedure of two arguments: some value and a new continuation \texttt{k\^{}\^{}}. At this point, the current continuation is \texttt{k\^{}\^{}}. Though, we do not want to invoke \texttt{k\^{}\^{}} on the passed value, but rather we want to invoke the continuation \textit{provided at the time of evaluating the body}, namely \texttt{k}. 

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-callcc-cps
 ((*;$\lambda$;*) (exp env k)
  (let ([body (second exp)])
   (value-of-cps body env
    ((*;$\lambda$;*) (f)
     (f ((*;$\lambda$;*) (v k^^) (k v)) k))))))
\end{lstlisting}\end{cl}

Running the above tests gets us the correct output as desired. Though, this code is very difficult to understand at first (and staring at it for hours on end rarely improves anything), so let us slow down and analyze each piece of this puzzle. To do this, we need to also take a look at \texttt{value-of-lambda-cps} and \texttt{value-of-application-cps}:

\begin{cl}[]{}\begin{lstlisting}[language=MyScheme]
(define value-of-lambda-cps
 ((*;$\lambda$;*) (exp env k)
  (let* ([loparam (second exp)]
         [x (first loparam)]
         [body (third exp)])
   (k ((*;$\lambda$;*) (arg k^)
    (value-of-cps body (extend-env x arg env) k^))))))

(define value-of-application-cps
 ((*;$\lambda$;*) (exp env k)
  (let ([rator (first exp)]
        [rand (second exp)])
   (value-of-cps rator env
    ((*;$\lambda$;*) (rat)
     (value-of-cps rand env
      ((*;$\lambda$;*) (ran)
       (rat ran k))))))))
\end{lstlisting}\end{cl}

Let us clarify something that we somewhat glossed over when defining these two functions. Our \texttt{lambda} case returns a procedure of two arguments: \texttt{arg} and \texttt{k\^{}}, meaning that whenever we invoke \texttt{rat}, or the operator of an application, we must give it two operands: the operand to the function (which we have repeatedly seen and is no different from the non-CPS'd counterpart) and the continuation to use in subsequent evaluations. 

With this understanding under our belt, let us analyze the \texttt{call/cc} reducer. Because it is written in continuation-passing style, we evaluate the body of the expression which, by definition, must be a procedure representing a continuation, e.g., \texttt{(call/cc (lambda (k) $\ldots$))}. Accordingly, the expression will always invoke the lambda reducer and return a procedure of two arguments. As such, we call this procedure \texttt{f} to denote its existence \textit{as} a procedure. 

Next, we call \texttt{f} and pass to it two arguments (as it should expect): a function of two arguments (\texttt{v} and \texttt{k\^{}}) and the current continuation \texttt{k}. Note that, because \texttt{f} is returned by the lambda reducer, it binds the function of two arguments to the formal parameter \texttt{arg} and the continuation to \texttt{k\^}. Inside of our language, whenever we decide to invoke the continuation, e.g., \texttt{(call/cc (lambda (k) (+ 2 (k 3))))}, we, as the programmer, give the continuation one argument which in this instance is \texttt{3}. The other argument, namely the continuation, is passed \textit{by the interpreter} within function application reduction. What matters, however, is what expression is bound to \texttt{k}. During evaluation of the \texttt{call/cc}'s \texttt{lambda}, we extend its environment to include a binding of \texttt{x} to \texttt{arg}. \texttt{x} is the continuation formal parameter, and \texttt{arg} is the two-argument \texttt{(lambda (v k\^{}\^{}) $\ldots$)}. Finally, we run into two cases: either we invoke the continuation or we do not. In the former case, the continuation from when the function was defined, i.e., \texttt{k}, is called with a value \texttt{v}, sending \texttt{v} out of the current context. Therefore, any remaining expressions to evaluate are ``terminated''. In the latter case, \texttt{k} is never invoked, meaning we never call \texttt{k} on some value \texttt{v}. The environment still contains a binding of \texttt{k} to the continuation; we just never invoke it. Instead, the value is evaluated via \texttt{value-of-cps} and returned like any other expression.

If we wanted, we could implement the remaining features in \nestedlang{PROC}, e.g., conditionals, local declarations, side-effects, and \texttt{begin!}, but we leave these as exercises to the reader.  

\exercise{1}{chapter-functional}{As a preliminary exercise, update \texttt{apply-env} to include an extra parameter representing a continuation. In addition, update its definition to invoke the continuation on the returned association value. This, consequently, means the dispatch \texttt{value-of} function should no longer invoke \texttt{k} on the expression returned by \texttt{apply-env}.}

\exercise{1}{chapter-functional}{Right now, this interpreter is not representation-independent with respect to closures; namely, we treat closures as functions. Write the helper functions \texttt{create-closure} and \texttt{apply-closure}. Note that \texttt{apply-closure}, like \texttt{apply-env}, should receive the continuation as a parameter. Then, update your \texttt{value-of-lambda} and \texttt{value-of-application} to call the closure helper functions.}

\exercise{1}{chapter-functional}{In addition to making environments and closures representation independent, continuations ought to receive similar treatment. Our interpreter assumes that continuations are functions, but that representation is by definition not mandatory! Write the \texttt{empty-k} and \texttt{apply-k} helper functions and replace every instance of functional continuations with these new functions. The representation of continuations is, by definition, irrelevant, but a functional representation is certainly the easiest to understand and use.}

\exercise{3}{chapter-functional}{Implement \texttt{let/cc}\index{\ttt{let/cc}}: a variant of \texttt{call/cc} that abstracts the \texttt{lambda} representation of continuations away. Think of it as a \texttt{let} binding but only for continuations. \texttt{let/cc} can be represented in terms of \texttt{call/cc}. For instance, the following two forms are equivalent.}

\begin{clrr}[]{}
\begin{lstlisting}[language=MyScheme]
(let/cc k (+ 2 3 (k 4)))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyNLNScheme]
(call/cc (lambda (k) (+ 2 3 (k 4))))
\end{lstlisting}
\end{clrr}

\clearpage
\subsection*{\nestedlang{PARTIAL}: Partial Evaluation Interpreter}

Consider the following expression: \texttt{((lambda (x y) (+ (+ x x) (+ y y))) 10)}. If we ran this in any of our current interpreters, the program would fail because the function expects two arguments, namely \texttt{x} and \texttt{y}, but received only one. It might be more beneficial, however, to have the program store the argument, namely \texttt{x}, inside a closure, and to return the closure for future evaluation. This form of evaluation is called \textit{partial evaluation}. A function that does not receive all arguments necessary to perform function application will return another function expecting those which remain. In the case of the above example, a partial evaluator generates a closure containing \texttt{(+ (+ x x) (+ y y))}, the formal parameter \texttt{y}, and a binding of $\texttt{x} \mapsto \texttt{10}$ inside the stored environment. In this section, we will write \nestedlang{PARTIAL}\index{\nestedlang{PARTIAL}}: a nested interpreter that implements a partial evaluator.

First, let us write the standard representation-independent (with respect to environments and closures) interpreter from earlier in this section. Our environment model is the same; we use an association list representation (because of this, we omit its inclusion in the listing). The closure model, though, differs because we will use a tagged list rather than a functional closure representation since we want access to formal parameter names. In addition to this change, we want our interpreter to support multi-arity functions, since there would be no partial evaluation with this exclusion. We will write a \texttt{extend-env-bindings} function that binds multiple formal parameters to multiple arguments using \texttt{foldr}.

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
;; extend-env-bindings : [ListOf Symbol] [ListOf Any] Environment -> Environment
;; Binds a list of formal parameters to the arguments in the given environment.
(define extend-env-bindings
 ((*;$\lambda$;*) (formals args env)
  (foldr ((*;$\lambda$;*) (formal arg acc-env)
          (extend-env formal arg acc-env))
         env
         formals
         args)))

(define create-closure
 ((*;$\lambda$;*) (vars body env)
  (list 'create-closure vars body env)))
         
(define apply-closure
 ((*;$\lambda$;*) (rator rands)
  (cond
   [(closure? rator) (value-of-closure rator rands)]
   [else #f])))
\end{lstlisting}
\end{cl}

The key to this nested interpreter rests inside \texttt{value-of-closure}. We want to extract the values from the closure tagged list. If the number of formal parameters to the closure is equal to the number of given arguments, then we perform standard function application on the body. On the other hand, if the number of operands $m$ is less than the number of required formals $n$, we return a new closure containing an extended environment with the first $m$ formal parameters bound to each operand. We also ``truncate'' the required formals from the closure, leaving $n - m$ formals left to be passed to the closure when invoked. To retrieve the first $m$ or last $m$ elements of a list, we take advantage of the naturally-recursive \texttt{take} and \texttt{drop} functions.

\begin{cl}[]{}
\begin{lstlisting}[language=MyScheme]
(define value-of-closure
 ((*;$\lambda$;*) (rator rands)
  (let ([vars (second rator)]
        [body (third rator)]
        [env (fourth rator)])
   (cond
    [(= (length vars) (length rands))
     (value-of body (extend-env-bindings vars rands env))]
    [else
     (let ([n (length rands)])
      (create-closure (drop vars n)
                      body
                      (extend-env-bindings (take vars n) rands env)))]))))
\end{lstlisting}
\end{cl}

Now, we can run the example from before. Let us pass one argument to the function, e.g., $10$, which becomes bound in the generated closure. At the same time, let us doubly invoke the function to see what happens:

\begin{clo}[]{}
\begin{lstlisting}[language=MySOutput]
(*;\textbf{>};*) (value-of 
   '((lambda (x y) (+ (* x x) (y y))) 10)
    (empty-env))

(*;\textbf{>};*) (value-of 
   '(((lambda (x y) (+ (* x x) (* y y))) 10) 20) 
   (base-env))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
(create-closure (y) 
 (+ (* x x) (y y)) 
 ((x . 10)))
 
500
\end{lstlisting}
\end{clo}

When we call the function with only one argument, we receive a closure, as expected, with \texttt{x} bound to \texttt{10}. In the second invocation, the function produces \texttt{500} because all its arguments are fulfilled with values. Partial evaluation is handy as it allows us to define functions without the need for explicit definitions of said functions. As an example, we can write \texttt{add1} as a partial application of the previous procedure.

\begin{clo}[]{}
\begin{lstlisting}[language=MySOutput]
(*;\textbf{>};*) (value-of 
   '((lambda (x y) (+ (* x x) (y y))) 1)
   (empty-env))

(*;\textbf{>};*) (value-of 
   '(((lambda (x y) (+ (* x x) (* y y))) 1) 15) 
   (base-env))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
(create-closure (y) 
 (+ (* x x) (y y)) 
 ((x . 1)))
 
16
\end{lstlisting}
\end{clo}

We could also write the higher-order function \texttt{map} that creates a \texttt{map-add1} function that, as its name suggests, returns a mapping function that adds one to each element of a list. First, let us write \texttt{map} in a \texttt{let} binding using the recursive lexical scoping\index{lexical scoping} technique from Chapter~\ref{chapter-interpretation2}.

\begin{clo}[]{}
\begin{lstlisting}[language=MySOutput]
(*;\textbf{>};*) (value-of 
   '(let ([map 
           (lambda (m f ls)
            (if (null? ls)
                (quote ())
                (cons (f (first ls))
                      (m m f (rest ls)))))])
     (map 
       map 
       (lambda (x) (+ x 1))
       (cons 1 
        (cons 2 
         (cons 3 
          (cons 4 
           (quote ())))))))
   (empty-env))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
(2 3 4 5)
\end{lstlisting}
\end{clo}

This is what we anticipated, but let us use partial evaluation to get the desired \texttt{map-add1} procedure.

\begin{clo}[]{}
\begin{lstlisting}[language=MySOutput]
(*;\textbf{>};*) (value-of 
   '(let ([add1
           (lambda (x) (+ x 1))]
     (let ([map 
            (lambda (m f ls)
             (if (null? ls)
                 (quote ())
                 (cons (f (first ls))
                       (m m f (rest ls)))))])
      (let ([map-add1 (map map add1)])
       (map-add1 (cons 1 
                  (cons 2 
                   (cons 3 
                    (cons 4 
                     (quote ()))))))))
   (empty-env))
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyOutput]
(2 3 4 5)
\end{lstlisting}
\end{clo}